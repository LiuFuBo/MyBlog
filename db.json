{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1498816166000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1498816166000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1498816166000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1498816166000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1498816166000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1498816166000},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1498816166000},{"_id":"themes/yilia/_config.yml","hash":"2f1c90f1ba13c6a9a37f3e0f55876ccbbfcf1b4e","modified":1499421272000},{"_id":"themes/yilia/.DS_Store","hash":"ca2d51bd80bd56c7608512880c2fe950b2eae935","modified":1499421972000},{"_id":"source/.DS_Store","hash":"f975391b3504239d65f0b69b81368925c79a953e","modified":1499422684000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1498816166000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1498816166000},{"_id":"source/_posts/.DS_Store","hash":"49b8d4e80a0356803b4aaadc60ecb9f9839b62f3","modified":1499418407000},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"699e6e00432c30e1781533afd65f490dc99187a5","modified":1498816577000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1498816166000},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"597a0d14c701a189e5d74eaa70341e78e3ad7c80","modified":1498816577000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1498816166000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1498815909000},{"_id":"themes/yilia/.git/index","hash":"d29e9eed9a0db9e5eb990ac83cafd68e316f120c","modified":1498816166000},{"_id":"themes/yilia/.git/packed-refs","hash":"cf41ff42218453f57f86f8bf8a37ce6b19a31ad9","modified":1498816166000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1498816166000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1498816166000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1498816166000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1498816166000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1498816166000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1498816166000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1498816166000},{"_id":"themes/yilia/layout/.DS_Store","hash":"9258eb78ff012d30cafef15ae33279a80e2293d0","modified":1499399111000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1498816166000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1498816166000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1498816166000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1498816166000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1498816166000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1498816166000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1498816166000},{"_id":"themes/yilia/source/.DS_Store","hash":"c5da644805e783b0d1d06ed6d1586b1dff9e36eb","modified":1499422115000},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1498816166000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1498816166000},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1498816166000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1498816166000},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1498816166000},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1498816166000},{"_id":"source/_posts/JavaScriptCore的巨坑/.DS_Store","hash":"9555e2204e61867a5acaffdbbd3c29ec766be1ea","modified":1499330576000},{"_id":"source/_posts/JavaScriptCore的巨坑/JavaScriptCore的巨坑.md","hash":"ae83ecfddfa00139e35b98f2bea1be717f42b0c3","modified":1499331316000},{"_id":"source/_posts/NSClassFromString-NSSelectorFromString/.DS_Store","hash":"958bfb20ed02a2c214d2ac74a7a01386205323e1","modified":1499331779000},{"_id":"source/_posts/NSClassFromString-NSSelectorFromString/NSClassFromString-NSSelectorFromString.md","hash":"8d18cdd590e0cc1dd2cd7f48be92bd22b97b74a1","modified":1499331700000},{"_id":"source/_posts/button横向自动排布的几种方式/.DS_Store","hash":"4f3c4b045e0a05c9612c0f636373fc7ca5354bb3","modified":1499337874000},{"_id":"source/_posts/button横向自动排布的几种方式/button横向自动排布的几种方式.md","hash":"80ddd76ff104d02d38d81976f2f4ff3c55cba008","modified":1499338215000},{"_id":"source/_posts/如何填补友盟分享新浪微博的那些坑/.DS_Store","hash":"ab758809c9d77da4e38525c632a408f77ef2fb0b","modified":1499338295000},{"_id":"source/_posts/如何填补友盟分享新浪微博的那些坑/如何填补友盟分享新浪微博的那些坑.md","hash":"654420cc5fb3cb3670998a388ff654cdb16dd4f9","modified":1499338585000},{"_id":"source/_posts/cocoaPods升级后遇到的巨坑/.DS_Store","hash":"b2659191cf91c6c28f237ee9dbb373a4eeb7c570","modified":1499328212000},{"_id":"source/_posts/cocoaPods升级后遇到的巨坑/cocoaPods升级后遇到的巨坑.md","hash":"a7242d4ac5d43c04d6ccb69080f86abb6e78cc73","modified":1499332270000},{"_id":"source/_posts/如果通过cocoaPods创建私有库/.DS_Store","hash":"edc74e8859af07aae30875e6c4fb5d1349b12f0b","modified":1499326077000},{"_id":"source/_posts/如果通过cocoaPods创建私有库/如果通过cocoaPods创建私有库.md","hash":"89d620169ec6637a8407e1619ec4cac3b4827a65","modified":1499332237000},{"_id":"source/_posts/对NSString字符串全部API作解释/.DS_Store","hash":"a57eeefb2d380f2c03bc105743ecfb0d6edfa226","modified":1499332425000},{"_id":"source/_posts/性能检测要怎么玩才尽兴/.DS_Store","hash":"58e559b9d2584dda7edce40aabf040cee564b024","modified":1499330563000},{"_id":"source/_posts/对NSString字符串全部API作解释/对NSString字符串全部API作解释.md","hash":"107f9ab9823180b953f0dccf44703e0352a08c01","modified":1499337738000},{"_id":"source/_posts/性能检测要怎么玩才尽兴/性能检测要怎么玩才尽兴.md","hash":"383048d45e6e4bd8f221307c10cd22593d17610a","modified":1499332355000},{"_id":"source/_posts/抓包工具charles/.DS_Store","hash":"f31c23e947fe3c2997dca26d1c7f2a039be5cfff","modified":1499325156000},{"_id":"source/_posts/抓包工具charles/抓包工具charles.md","hash":"5385dfd907fb7227bda9d70b5b568934a858dd8a","modified":1499325618000},{"_id":"source/_posts/配置PodSpec.文件容易遇到的问题/.DS_Store","hash":"4145ccc0c1640eb584f6b7b91ac8712bfe3f0670","modified":1499162796000},{"_id":"source/_posts/配置PodSpec.文件容易遇到的问题/配置PodSpec.文件容易遇到的问题.md","hash":"e058207291140ad8aac50acc1f725157723de587","modified":1499419193000},{"_id":"source/_posts/高德地图的使用技巧/.DS_Store","hash":"0be5193371313383a7ce7bd9175fdca3a01a672a","modified":1499332407000},{"_id":"source/_posts/高德地图的使用技巧/高德地图的使用技巧.md","hash":"1aba70b4f152aac6a5627ff7d26cc7b566527acc","modified":1499332132000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1498815909000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1498815909000},{"_id":"themes/yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1498815909000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"1ddc3ba22499292c8edaa634f2b860c539b39592","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1498816166000},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1498816166000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1498816166000},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1498816166000},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1498816166000},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1498816166000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1498816166000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1498816166000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1498816166000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1498816166000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1498816166000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1498816166000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1498816166000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1498816166000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1498816166000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1498816166000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1498816166000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1498816166000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1498816166000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1498816166000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1498816166000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1498816166000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1498816166000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1498816166000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1498816166000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1498816166000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1498816166000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1498816166000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1498816166000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1498816166000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1498816166000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1498816166000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1498816166000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1498816166000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1498816166000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1498816166000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1498816166000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1498816166000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1498816166000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1498816166000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1498816166000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1498816166000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1498816166000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1498816166000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1498816166000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1498816166000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1498816166000},{"_id":"themes/yilia/.git/objects/pack/pack-149e73dd21ac165412f3146538f0edfe9cab3b36.idx","hash":"b5c96f156ea151d3839346b96cf9478dc0c7e181","modified":1498816166000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"597a0d14c701a189e5d74eaa70341e78e3ad7c80","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1498816166000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1498816166000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1498816166000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1498816166000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1498816166000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1498816166000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1498816166000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1498816166000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1498816166000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1498816166000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1498816166000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1498816166000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1498816166000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1498816166000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"1ddc3ba22499292c8edaa634f2b860c539b39592","modified":1498816166000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1498816166000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"1ddc3ba22499292c8edaa634f2b860c539b39592","modified":1498816166000},{"_id":"themes/yilia/.git/objects/pack/pack-149e73dd21ac165412f3146538f0edfe9cab3b36.pack","hash":"ac7f9af6c96969bf7610ba6c41a96860378baac3","modified":1498816166000},{"_id":"public/content.json","hash":"42862cbe877196b93525955cc63d55602a898630","modified":1499422700533},{"_id":"public/2017/07/06/如何填补友盟分享新浪微博的那些坑/如何填补友盟分享新浪微博的那些坑/index.html","hash":"6a9f65e91d4ca57ede49b06ab93d7c674ecb777a","modified":1499422700705},{"_id":"public/2017/07/06/button横向自动排布的几种方式/button横向自动排布的几种方式/index.html","hash":"9c368432c72318fc73506b192e00ced58f981234","modified":1499422700705},{"_id":"public/2017/07/06/对NSString字符串全部API作解释/对NSString字符串全部API作解释/index.html","hash":"7458ad6ed787d41dee976931e0605bb8be4e02d1","modified":1499422700705},{"_id":"public/2017/07/06/高德地图的使用技巧/高德地图的使用技巧/index.html","hash":"ef9bea8b3da42e409b4e358d6ceb86f53c5ea216","modified":1499422700705},{"_id":"public/2017/07/06/NSClassFromString-NSSelectorFromString/NSClassFromString-NSSelectorFromString/index.html","hash":"c0a2fe801e16291cbd37a50e8101100327d05a08","modified":1499422700706},{"_id":"public/2017/07/06/JavaScriptCore的巨坑/JavaScriptCore的巨坑/index.html","hash":"c541cd5298724b9d54e2960c69126e6d5b4149e2","modified":1499422700706},{"_id":"public/2017/07/06/性能检测要怎么玩才尽兴/性能检测要怎么玩才尽兴/index.html","hash":"4a8fb1af757c4803f156aa9366827f00d3bb97b9","modified":1499422700706},{"_id":"public/2017/07/06/cocoaPods升级后遇到的巨坑/cocoaPods升级后遇到的巨坑/index.html","hash":"63172c556b07dca30eb15bcc58520f70a828a977","modified":1499422700706},{"_id":"public/2017/07/06/如果通过cocoaPods创建私有库/如果通过cocoaPods创建私有库/index.html","hash":"8dadca222b8630365f14ef749015bd320d105ac9","modified":1499422700706},{"_id":"public/2017/07/06/抓包工具charles/抓包工具charles/index.html","hash":"db794f2f19e36730dde0733d550d41860c94af29","modified":1499422700707},{"_id":"public/2017/07/04/配置PodSpec.文件容易遇到的问题/配置PodSpec.文件容易遇到的问题/index.html","hash":"01a6179d5eafd146c41d8dfff4590721b8efb233","modified":1499422700707},{"_id":"public/archives/index.html","hash":"bd5532d1e6416d1b484ca0f9114a791bb8f3a21c","modified":1499422700707},{"_id":"public/archives/2017/index.html","hash":"8ab5db13d2abfd45f2deac12f9fa3392310f068e","modified":1499422700708},{"_id":"public/archives/2017/07/index.html","hash":"a9d0dbbd4c76a08f405037b122186d45ac22e760","modified":1499422700708},{"_id":"public/index.html","hash":"0a39b2c1e1426ed3ec3e18fcf9d26d4e6d59f81b","modified":1499422700708},{"_id":"public/page/2/index.html","hash":"89af390cef1375f851293216c9e9c69093552e35","modified":1499422700708},{"_id":"public/tags/javascript/index.html","hash":"dfbdd369ec3503af28279c5d2a75f0962d5ebb79","modified":1499422700708},{"_id":"public/tags/技术/index.html","hash":"89d2be98a36dae10d6f560b85a58baf0238d3b45","modified":1499422700708},{"_id":"public/tags/分享/index.html","hash":"a475403010b51cab71739983c47c58a1ae7ed51c","modified":1499422700709},{"_id":"public/tags/第三方/index.html","hash":"adeba9b478c7d1901a4ef7a9a3a388e5ddbcec94","modified":1499422700709},{"_id":"public/tags/cocoaPods/index.html","hash":"aa79f06190d3ce0284193246a0ba7d09716104a4","modified":1499422700709},{"_id":"public/tags/终端/index.html","hash":"d4ededf58aacbf74b15100d7f68518a5f44aac60","modified":1499422700709},{"_id":"public/tags/私有库/index.html","hash":"b2b7e677b2d5f565befa1d0ffbeea7c3e675d4fb","modified":1499422700709},{"_id":"public/tags/API/index.html","hash":"b678f14d7102395fee084ad887c631aa05ac3a18","modified":1499422700709},{"_id":"public/tags/Instruments/index.html","hash":"b83695ae9e9bc96ee69d39533f841f432815ca5a","modified":1499422700709},{"_id":"public/tags/性能检测/index.html","hash":"12e6c343d443a4e87975e8e39c783413f6b4a795","modified":1499422700709},{"_id":"public/tags/工具/index.html","hash":"154ab8ef8466bb30645b1736e22cdb1343047e4e","modified":1499422700709},{"_id":"public/tags/黑魔法/index.html","hash":"2cfc6a882e7de0857f89148b7a894b2a839eeda9","modified":1499422700709},{"_id":"public/tags/地图/index.html","hash":"4fde46e848ca4f212f6133e17daa59e66da02b1d","modified":1499422700709},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1499422700712},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1499422700712},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1499422700713},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1499422700713},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1499422700713},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1499422700713},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1499422700713},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1499422700713},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1499422700713},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1499422700717},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1499422700717},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1499422700717},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1499422700717}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"JavaScriptCore的巨坑（JSExportAs方式绑定的本地通信）","date":"2017-07-06T08:42:37.000Z","_content":"\n# 前言\n\n本篇分享的类型不是学习教程，并且要有一点JavaScriptCore基础，\n         \n         毕竟这一块网上一大堆的学习教程，博主就没必要班门弄斧了。\n\n本篇的目的是分享JavaScriptCore中用JSExport协议和JSExportAs宏来进行js和oc通信的两个大坑。\n<!-- more -->\n\n1.内存泄露\n\n2.调用-[JSValue callWithArguments]野指针问题\n\n     注: 用block方式来进行js和oc的通信没这两个大坑。\n\n# 第一个坑：内存泄露\n\n一般绑定JSContext里的native的写法都是self.context[@\"native\"] = self。但是这样写会产生内存泄露（泄露原理就是互相持有了），这个坑随便百度Google一下也能找到很多解决方案。目前博主的解决方案是native指定一个新的对象，然后在指定对象里实现JSExport协议。\n贴上博主在项目里用到的核心代码 :\n\n### 和js通信的控制器页面核心代码\n\t{// 以 JSExport 协议关联 native 的方法\n\tself.context[@\"native\"] = [[NMFormFlowWapNativeManager alloc] initWithDelegate:self];}\n\t\n\t\n### NMFormFlowWapNativeManager.h\n\t{@interface NMFormFlowWapNativeManager : NSObject\n\n\t- (instancetype)initWithDelegate:(id<NMFormFlowWapNativeManagerDelegate>)delegate;\n\n\t@property (nonatomic,weak) id<NMFormFlowWapNativeManagerDelegate> delegate;\n\n\t@end}\n\t\n\t\n### NMFormFlowWapNativeManager.m\n\n\t{@import JavaScriptCore;\n\n\t@protocol TestJSExport <JSExport>\n\n\tJSExportAs(nativeCall, - (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jstype);\n\n\t@end\n\n\t@interface NMFormFlowWapNativeManager () <TestJSExport>\n\n\t@end\n\n\t@implementation NMFormFlowWapNativeManager\n\n\t- (instancetype)initWithDelegate:(id<NMFormFlowWapNativeManagerDelegate>)delegate {\n    if (self = [super init]) {\n        self.delegate = delegate;\n    }\n    return self;\n\t}\n\n\t- (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jsType {\n    NSDictionary *dicParams = [NSJSONSerialization JSONObjectWithData:[parameter dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil];\n    [self.delegate nativeCallHandleWithThread:webThread type:nativeType parameter:dicParams jsType:jsType];\n\t}}\n\t\n\t\n PS:代码并不是完整的，但最核心的关键已经贴上来了。顺便简单解释一下。由于native管理的对象交给了另一个，所以在管理者对象里新开了一个代理回调。方便在控制器那边接收得到JS的事件。只要有点基础的，一看就懂了。毕竟本篇不是学习教程，而是分享坑的。\n \n# 第二个坑：-[JSValue callWithArguments]野指针问题\n\n这个问题有点奇葩，JSValue的callWithArguments就是oc调用js函数所执行的方法。那这简单的函数怎么发生野指针问题尼。\n那就是oc进行网络请求，请求完回调的时候调用JSValue的callWithArguments的方法就是产生野指针，而且是间接性的，有时候会有时候不会。一旦崩溃基本都直接飞去main函数了。。。。\n\n 这个问题百度Google都找了许久也没找到类似的问题和解决方案。只是崩溃的时候，左边的堆栈提示webThread（当时猜测可能是线程间通信影响的此问题），然后我蒙一下切换到webView的线程里去调用callWithArguments函数试试，结果就从未发生过崩溃了。\n \n# 例子：\n假设，h5上有一个图片显示和一个button，点击button的时候，调用本地摄像头并且上传图片到服务器，上传完之后在调用js一个函数，告诉js图片上传成功，让js去做对应的逻辑。这个时候网络请求完回调里的线程是主线程，调用callWithArguments的时候，就会间接性的崩溃。\n\n# 解决方案\n\n解决办法就是回到webView的线程去调用callWithArguments就不会崩溃（因为js和oc绑定的函数，在函数里执行的代码不是在主线程里执行的）。\n模拟代码：\n\n\t{///假设这个函数是和js的test函数绑定的。如果监听到这个函数就进行网络请求或者上传图片等操作。\n\t- (void)test {\n \t //获取webView线程，因为js和oc绑定的函数里执行的代码不是在主线程里。\n\tNSThread *webThread = [NSThread currentThread];\n\t//网络请求\n\t@weakify(self);\n\t[HTTPRequest requestGetTokenWithFinished:^(void){\n \t @strongify(self);\n\n  \t//通知js请求完了。\n\n \t//正常情况下是直接在这里调用，但是会间接性发生野指针问题，差不多每隔四五次发生一次野指针。\n \t //JSValue *jsCall = self.context[@\"jsCall\"];\n \t //[jsCall callWithArguments:nil];\n\n \t //线程安全的，用此方式，笔者再也没发生过野指针问题。\n  \t[self performSelector:@selector(jsCall) onThread:webThread withObject:nil waitUntilDone:NO];\n\t}];\n\t}\n\n\t- (void)jsCall {\n \t JSValue *jsCall = self.context[@\"jsCall\"];\n \t [jsCall callWithArguments:nil];\n\t}}\n\t\n#\t结语\n\n总之笔者分享此文章的主要目的是第二个野指针问题，因为笔者在Google和stackoverflow里也找了很久也找不到问题原因，然后都是蒙对的，所以才来进行分享。可能对于不懂JavaScriptCore看起来有点困难，总之可以先了解一下。而对于js和oc的通信的业务不复杂的或者使用block进行通信的，应该很难遇到此问题。再者，网上很多学习教程基本都是推荐callWithArguments在主线程里调用，但目前笔者认为应该还是让它在webView的线程里去执行（那个野指针问题就是在主线程里执行所发生的）。\n\n而callWithArguments野指针问题的底层实际发生原理也并不是很清楚。所以目前只能说博主是怎么解决的，但是为什么.....博主也不知其然了。有知道的方便的话也可告知一下。\n\n而对于demo.....笔者也想写，但对于html、js并不是很熟悉（顶多看得懂几个标签）。所以....无能为力奉上demo了。","source":"_posts/JavaScriptCore的巨坑/JavaScriptCore的巨坑.md","raw":"---\ntitle: JavaScriptCore的巨坑（JSExportAs方式绑定的本地通信）\ndate: 2017-07-06 16:42:37\ntags:\n  - javascript \n---\n\n# 前言\n\n本篇分享的类型不是学习教程，并且要有一点JavaScriptCore基础，\n         \n         毕竟这一块网上一大堆的学习教程，博主就没必要班门弄斧了。\n\n本篇的目的是分享JavaScriptCore中用JSExport协议和JSExportAs宏来进行js和oc通信的两个大坑。\n<!-- more -->\n\n1.内存泄露\n\n2.调用-[JSValue callWithArguments]野指针问题\n\n     注: 用block方式来进行js和oc的通信没这两个大坑。\n\n# 第一个坑：内存泄露\n\n一般绑定JSContext里的native的写法都是self.context[@\"native\"] = self。但是这样写会产生内存泄露（泄露原理就是互相持有了），这个坑随便百度Google一下也能找到很多解决方案。目前博主的解决方案是native指定一个新的对象，然后在指定对象里实现JSExport协议。\n贴上博主在项目里用到的核心代码 :\n\n### 和js通信的控制器页面核心代码\n\t{// 以 JSExport 协议关联 native 的方法\n\tself.context[@\"native\"] = [[NMFormFlowWapNativeManager alloc] initWithDelegate:self];}\n\t\n\t\n### NMFormFlowWapNativeManager.h\n\t{@interface NMFormFlowWapNativeManager : NSObject\n\n\t- (instancetype)initWithDelegate:(id<NMFormFlowWapNativeManagerDelegate>)delegate;\n\n\t@property (nonatomic,weak) id<NMFormFlowWapNativeManagerDelegate> delegate;\n\n\t@end}\n\t\n\t\n### NMFormFlowWapNativeManager.m\n\n\t{@import JavaScriptCore;\n\n\t@protocol TestJSExport <JSExport>\n\n\tJSExportAs(nativeCall, - (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jstype);\n\n\t@end\n\n\t@interface NMFormFlowWapNativeManager () <TestJSExport>\n\n\t@end\n\n\t@implementation NMFormFlowWapNativeManager\n\n\t- (instancetype)initWithDelegate:(id<NMFormFlowWapNativeManagerDelegate>)delegate {\n    if (self = [super init]) {\n        self.delegate = delegate;\n    }\n    return self;\n\t}\n\n\t- (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jsType {\n    NSDictionary *dicParams = [NSJSONSerialization JSONObjectWithData:[parameter dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil];\n    [self.delegate nativeCallHandleWithThread:webThread type:nativeType parameter:dicParams jsType:jsType];\n\t}}\n\t\n\t\n PS:代码并不是完整的，但最核心的关键已经贴上来了。顺便简单解释一下。由于native管理的对象交给了另一个，所以在管理者对象里新开了一个代理回调。方便在控制器那边接收得到JS的事件。只要有点基础的，一看就懂了。毕竟本篇不是学习教程，而是分享坑的。\n \n# 第二个坑：-[JSValue callWithArguments]野指针问题\n\n这个问题有点奇葩，JSValue的callWithArguments就是oc调用js函数所执行的方法。那这简单的函数怎么发生野指针问题尼。\n那就是oc进行网络请求，请求完回调的时候调用JSValue的callWithArguments的方法就是产生野指针，而且是间接性的，有时候会有时候不会。一旦崩溃基本都直接飞去main函数了。。。。\n\n 这个问题百度Google都找了许久也没找到类似的问题和解决方案。只是崩溃的时候，左边的堆栈提示webThread（当时猜测可能是线程间通信影响的此问题），然后我蒙一下切换到webView的线程里去调用callWithArguments函数试试，结果就从未发生过崩溃了。\n \n# 例子：\n假设，h5上有一个图片显示和一个button，点击button的时候，调用本地摄像头并且上传图片到服务器，上传完之后在调用js一个函数，告诉js图片上传成功，让js去做对应的逻辑。这个时候网络请求完回调里的线程是主线程，调用callWithArguments的时候，就会间接性的崩溃。\n\n# 解决方案\n\n解决办法就是回到webView的线程去调用callWithArguments就不会崩溃（因为js和oc绑定的函数，在函数里执行的代码不是在主线程里执行的）。\n模拟代码：\n\n\t{///假设这个函数是和js的test函数绑定的。如果监听到这个函数就进行网络请求或者上传图片等操作。\n\t- (void)test {\n \t //获取webView线程，因为js和oc绑定的函数里执行的代码不是在主线程里。\n\tNSThread *webThread = [NSThread currentThread];\n\t//网络请求\n\t@weakify(self);\n\t[HTTPRequest requestGetTokenWithFinished:^(void){\n \t @strongify(self);\n\n  \t//通知js请求完了。\n\n \t//正常情况下是直接在这里调用，但是会间接性发生野指针问题，差不多每隔四五次发生一次野指针。\n \t //JSValue *jsCall = self.context[@\"jsCall\"];\n \t //[jsCall callWithArguments:nil];\n\n \t //线程安全的，用此方式，笔者再也没发生过野指针问题。\n  \t[self performSelector:@selector(jsCall) onThread:webThread withObject:nil waitUntilDone:NO];\n\t}];\n\t}\n\n\t- (void)jsCall {\n \t JSValue *jsCall = self.context[@\"jsCall\"];\n \t [jsCall callWithArguments:nil];\n\t}}\n\t\n#\t结语\n\n总之笔者分享此文章的主要目的是第二个野指针问题，因为笔者在Google和stackoverflow里也找了很久也找不到问题原因，然后都是蒙对的，所以才来进行分享。可能对于不懂JavaScriptCore看起来有点困难，总之可以先了解一下。而对于js和oc的通信的业务不复杂的或者使用block进行通信的，应该很难遇到此问题。再者，网上很多学习教程基本都是推荐callWithArguments在主线程里调用，但目前笔者认为应该还是让它在webView的线程里去执行（那个野指针问题就是在主线程里执行所发生的）。\n\n而callWithArguments野指针问题的底层实际发生原理也并不是很清楚。所以目前只能说博主是怎么解决的，但是为什么.....博主也不知其然了。有知道的方便的话也可告知一下。\n\n而对于demo.....笔者也想写，但对于html、js并不是很熟悉（顶多看得懂几个标签）。所以....无能为力奉上demo了。","slug":"JavaScriptCore的巨坑/JavaScriptCore的巨坑","published":1,"updated":"2017-07-06T08:55:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xi00009yho3bbipeq8","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇分享的类型不是学习教程，并且要有一点JavaScriptCore基础，</p>\n<pre><code>毕竟这一块网上一大堆的学习教程，博主就没必要班门弄斧了。\n</code></pre><p>本篇的目的是分享JavaScriptCore中用JSExport协议和JSExportAs宏来进行js和oc通信的两个大坑。<br><a id=\"more\"></a></p>\n<p>1.内存泄露</p>\n<p>2.调用-[JSValue callWithArguments]野指针问题</p>\n<pre><code>注: 用block方式来进行js和oc的通信没这两个大坑。\n</code></pre><h1 id=\"第一个坑：内存泄露\"><a href=\"#第一个坑：内存泄露\" class=\"headerlink\" title=\"第一个坑：内存泄露\"></a>第一个坑：内存泄露</h1><p>一般绑定JSContext里的native的写法都是self.context[@”native”] = self。但是这样写会产生内存泄露（泄露原理就是互相持有了），这个坑随便百度Google一下也能找到很多解决方案。目前博主的解决方案是native指定一个新的对象，然后在指定对象里实现JSExport协议。<br>贴上博主在项目里用到的核心代码 :</p>\n<h3 id=\"和js通信的控制器页面核心代码\"><a href=\"#和js通信的控制器页面核心代码\" class=\"headerlink\" title=\"和js通信的控制器页面核心代码\"></a>和js通信的控制器页面核心代码</h3><pre><code>{// 以 JSExport 协议关联 native 的方法\nself.context[@&quot;native&quot;] = [[NMFormFlowWapNativeManager alloc] initWithDelegate:self];}\n</code></pre><h3 id=\"NMFormFlowWapNativeManager-h\"><a href=\"#NMFormFlowWapNativeManager-h\" class=\"headerlink\" title=\"NMFormFlowWapNativeManager.h\"></a>NMFormFlowWapNativeManager.h</h3><pre><code>{@interface NMFormFlowWapNativeManager : NSObject\n\n- (instancetype)initWithDelegate:(id&lt;NMFormFlowWapNativeManagerDelegate&gt;)delegate;\n\n@property (nonatomic,weak) id&lt;NMFormFlowWapNativeManagerDelegate&gt; delegate;\n\n@end}\n</code></pre><h3 id=\"NMFormFlowWapNativeManager-m\"><a href=\"#NMFormFlowWapNativeManager-m\" class=\"headerlink\" title=\"NMFormFlowWapNativeManager.m\"></a>NMFormFlowWapNativeManager.m</h3><pre><code>{@import JavaScriptCore;\n\n@protocol TestJSExport &lt;JSExport&gt;\n\nJSExportAs(nativeCall, - (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jstype);\n\n@end\n\n@interface NMFormFlowWapNativeManager () &lt;TestJSExport&gt;\n\n@end\n\n@implementation NMFormFlowWapNativeManager\n\n- (instancetype)initWithDelegate:(id&lt;NMFormFlowWapNativeManagerDelegate&gt;)delegate {\nif (self = [super init]) {\n    self.delegate = delegate;\n}\nreturn self;\n}\n\n- (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jsType {\nNSDictionary *dicParams = [NSJSONSerialization JSONObjectWithData:[parameter dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil];\n[self.delegate nativeCallHandleWithThread:webThread type:nativeType parameter:dicParams jsType:jsType];\n}}\n</code></pre><p> PS:代码并不是完整的，但最核心的关键已经贴上来了。顺便简单解释一下。由于native管理的对象交给了另一个，所以在管理者对象里新开了一个代理回调。方便在控制器那边接收得到JS的事件。只要有点基础的，一看就懂了。毕竟本篇不是学习教程，而是分享坑的。</p>\n<h1 id=\"第二个坑：-JSValue-callWithArguments-野指针问题\"><a href=\"#第二个坑：-JSValue-callWithArguments-野指针问题\" class=\"headerlink\" title=\"第二个坑：-[JSValue callWithArguments]野指针问题\"></a>第二个坑：-[JSValue callWithArguments]野指针问题</h1><p>这个问题有点奇葩，JSValue的callWithArguments就是oc调用js函数所执行的方法。那这简单的函数怎么发生野指针问题尼。<br>那就是oc进行网络请求，请求完回调的时候调用JSValue的callWithArguments的方法就是产生野指针，而且是间接性的，有时候会有时候不会。一旦崩溃基本都直接飞去main函数了。。。。</p>\n<p> 这个问题百度Google都找了许久也没找到类似的问题和解决方案。只是崩溃的时候，左边的堆栈提示webThread（当时猜测可能是线程间通信影响的此问题），然后我蒙一下切换到webView的线程里去调用callWithArguments函数试试，结果就从未发生过崩溃了。</p>\n<h1 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h1><p>假设，h5上有一个图片显示和一个button，点击button的时候，调用本地摄像头并且上传图片到服务器，上传完之后在调用js一个函数，告诉js图片上传成功，让js去做对应的逻辑。这个时候网络请求完回调里的线程是主线程，调用callWithArguments的时候，就会间接性的崩溃。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>解决办法就是回到webView的线程去调用callWithArguments就不会崩溃（因为js和oc绑定的函数，在函数里执行的代码不是在主线程里执行的）。<br>模拟代码：</p>\n<pre><code>{///假设这个函数是和js的test函数绑定的。如果监听到这个函数就进行网络请求或者上传图片等操作。\n- (void)test {\n  //获取webView线程，因为js和oc绑定的函数里执行的代码不是在主线程里。\nNSThread *webThread = [NSThread currentThread];\n//网络请求\n@weakify(self);\n[HTTPRequest requestGetTokenWithFinished:^(void){\n  @strongify(self);\n\n  //通知js请求完了。\n\n //正常情况下是直接在这里调用，但是会间接性发生野指针问题，差不多每隔四五次发生一次野指针。\n  //JSValue *jsCall = self.context[@&quot;jsCall&quot;];\n  //[jsCall callWithArguments:nil];\n\n  //线程安全的，用此方式，笔者再也没发生过野指针问题。\n  [self performSelector:@selector(jsCall) onThread:webThread withObject:nil waitUntilDone:NO];\n}];\n}\n\n- (void)jsCall {\n  JSValue *jsCall = self.context[@&quot;jsCall&quot;];\n  [jsCall callWithArguments:nil];\n}}\n</code></pre><h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>总之笔者分享此文章的主要目的是第二个野指针问题，因为笔者在Google和stackoverflow里也找了很久也找不到问题原因，然后都是蒙对的，所以才来进行分享。可能对于不懂JavaScriptCore看起来有点困难，总之可以先了解一下。而对于js和oc的通信的业务不复杂的或者使用block进行通信的，应该很难遇到此问题。再者，网上很多学习教程基本都是推荐callWithArguments在主线程里调用，但目前笔者认为应该还是让它在webView的线程里去执行（那个野指针问题就是在主线程里执行所发生的）。</p>\n<p>而callWithArguments野指针问题的底层实际发生原理也并不是很清楚。所以目前只能说博主是怎么解决的，但是为什么…..博主也不知其然了。有知道的方便的话也可告知一下。</p>\n<p>而对于demo…..笔者也想写，但对于html、js并不是很熟悉（顶多看得懂几个标签）。所以….无能为力奉上demo了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇分享的类型不是学习教程，并且要有一点JavaScriptCore基础，</p>\n<pre><code>毕竟这一块网上一大堆的学习教程，博主就没必要班门弄斧了。\n</code></pre><p>本篇的目的是分享JavaScriptCore中用JSExport协议和JSExportAs宏来进行js和oc通信的两个大坑。<br>","more":"</p>\n<p>1.内存泄露</p>\n<p>2.调用-[JSValue callWithArguments]野指针问题</p>\n<pre><code>注: 用block方式来进行js和oc的通信没这两个大坑。\n</code></pre><h1 id=\"第一个坑：内存泄露\"><a href=\"#第一个坑：内存泄露\" class=\"headerlink\" title=\"第一个坑：内存泄露\"></a>第一个坑：内存泄露</h1><p>一般绑定JSContext里的native的写法都是self.context[@”native”] = self。但是这样写会产生内存泄露（泄露原理就是互相持有了），这个坑随便百度Google一下也能找到很多解决方案。目前博主的解决方案是native指定一个新的对象，然后在指定对象里实现JSExport协议。<br>贴上博主在项目里用到的核心代码 :</p>\n<h3 id=\"和js通信的控制器页面核心代码\"><a href=\"#和js通信的控制器页面核心代码\" class=\"headerlink\" title=\"和js通信的控制器页面核心代码\"></a>和js通信的控制器页面核心代码</h3><pre><code>{// 以 JSExport 协议关联 native 的方法\nself.context[@&quot;native&quot;] = [[NMFormFlowWapNativeManager alloc] initWithDelegate:self];}\n</code></pre><h3 id=\"NMFormFlowWapNativeManager-h\"><a href=\"#NMFormFlowWapNativeManager-h\" class=\"headerlink\" title=\"NMFormFlowWapNativeManager.h\"></a>NMFormFlowWapNativeManager.h</h3><pre><code>{@interface NMFormFlowWapNativeManager : NSObject\n\n- (instancetype)initWithDelegate:(id&lt;NMFormFlowWapNativeManagerDelegate&gt;)delegate;\n\n@property (nonatomic,weak) id&lt;NMFormFlowWapNativeManagerDelegate&gt; delegate;\n\n@end}\n</code></pre><h3 id=\"NMFormFlowWapNativeManager-m\"><a href=\"#NMFormFlowWapNativeManager-m\" class=\"headerlink\" title=\"NMFormFlowWapNativeManager.m\"></a>NMFormFlowWapNativeManager.m</h3><pre><code>{@import JavaScriptCore;\n\n@protocol TestJSExport &lt;JSExport&gt;\n\nJSExportAs(nativeCall, - (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jstype);\n\n@end\n\n@interface NMFormFlowWapNativeManager () &lt;TestJSExport&gt;\n\n@end\n\n@implementation NMFormFlowWapNativeManager\n\n- (instancetype)initWithDelegate:(id&lt;NMFormFlowWapNativeManagerDelegate&gt;)delegate {\nif (self = [super init]) {\n    self.delegate = delegate;\n}\nreturn self;\n}\n\n- (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jsType {\nNSDictionary *dicParams = [NSJSONSerialization JSONObjectWithData:[parameter dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil];\n[self.delegate nativeCallHandleWithThread:webThread type:nativeType parameter:dicParams jsType:jsType];\n}}\n</code></pre><p> PS:代码并不是完整的，但最核心的关键已经贴上来了。顺便简单解释一下。由于native管理的对象交给了另一个，所以在管理者对象里新开了一个代理回调。方便在控制器那边接收得到JS的事件。只要有点基础的，一看就懂了。毕竟本篇不是学习教程，而是分享坑的。</p>\n<h1 id=\"第二个坑：-JSValue-callWithArguments-野指针问题\"><a href=\"#第二个坑：-JSValue-callWithArguments-野指针问题\" class=\"headerlink\" title=\"第二个坑：-[JSValue callWithArguments]野指针问题\"></a>第二个坑：-[JSValue callWithArguments]野指针问题</h1><p>这个问题有点奇葩，JSValue的callWithArguments就是oc调用js函数所执行的方法。那这简单的函数怎么发生野指针问题尼。<br>那就是oc进行网络请求，请求完回调的时候调用JSValue的callWithArguments的方法就是产生野指针，而且是间接性的，有时候会有时候不会。一旦崩溃基本都直接飞去main函数了。。。。</p>\n<p> 这个问题百度Google都找了许久也没找到类似的问题和解决方案。只是崩溃的时候，左边的堆栈提示webThread（当时猜测可能是线程间通信影响的此问题），然后我蒙一下切换到webView的线程里去调用callWithArguments函数试试，结果就从未发生过崩溃了。</p>\n<h1 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h1><p>假设，h5上有一个图片显示和一个button，点击button的时候，调用本地摄像头并且上传图片到服务器，上传完之后在调用js一个函数，告诉js图片上传成功，让js去做对应的逻辑。这个时候网络请求完回调里的线程是主线程，调用callWithArguments的时候，就会间接性的崩溃。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>解决办法就是回到webView的线程去调用callWithArguments就不会崩溃（因为js和oc绑定的函数，在函数里执行的代码不是在主线程里执行的）。<br>模拟代码：</p>\n<pre><code>{///假设这个函数是和js的test函数绑定的。如果监听到这个函数就进行网络请求或者上传图片等操作。\n- (void)test {\n  //获取webView线程，因为js和oc绑定的函数里执行的代码不是在主线程里。\nNSThread *webThread = [NSThread currentThread];\n//网络请求\n@weakify(self);\n[HTTPRequest requestGetTokenWithFinished:^(void){\n  @strongify(self);\n\n  //通知js请求完了。\n\n //正常情况下是直接在这里调用，但是会间接性发生野指针问题，差不多每隔四五次发生一次野指针。\n  //JSValue *jsCall = self.context[@&quot;jsCall&quot;];\n  //[jsCall callWithArguments:nil];\n\n  //线程安全的，用此方式，笔者再也没发生过野指针问题。\n  [self performSelector:@selector(jsCall) onThread:webThread withObject:nil waitUntilDone:NO];\n}];\n}\n\n- (void)jsCall {\n  JSValue *jsCall = self.context[@&quot;jsCall&quot;];\n  [jsCall callWithArguments:nil];\n}}\n</code></pre><h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>总之笔者分享此文章的主要目的是第二个野指针问题，因为笔者在Google和stackoverflow里也找了很久也找不到问题原因，然后都是蒙对的，所以才来进行分享。可能对于不懂JavaScriptCore看起来有点困难，总之可以先了解一下。而对于js和oc的通信的业务不复杂的或者使用block进行通信的，应该很难遇到此问题。再者，网上很多学习教程基本都是推荐callWithArguments在主线程里调用，但目前笔者认为应该还是让它在webView的线程里去执行（那个野指针问题就是在主线程里执行所发生的）。</p>\n<p>而callWithArguments野指针问题的底层实际发生原理也并不是很清楚。所以目前只能说博主是怎么解决的，但是为什么…..博主也不知其然了。有知道的方便的话也可告知一下。</p>\n<p>而对于demo…..笔者也想写，但对于html、js并不是很熟悉（顶多看得懂几个标签）。所以….无能为力奉上demo了。</p>"},{"title":"NSClassFromString,NSSelectorFromString...","date":"2017-07-06T08:58:02.000Z","_content":"\n###  NSClassFromString\n\n这个方法判断类是否存在，如果存在就动态加载的，不存为就返回一个空对象;\n\nid myObj = [[NSClassFromString(@\"MyClass\") alloc] init];\n\n正常情况下等价于：id myObj = [[MyClass alloc] init];\n\n<!-- more -->\n优点：\n\n1， 弱化连接，因此并不会把没有的Framework也link到程序中。\n\n2，不需要使用import，因为类是动态加载的，只要存在就可以加载。因此如果你的toolchain中没有某个类的头文件定义，而你确信这个类是可以用的，那么也可以用这种方法。\n\n### NSSelectorFromString\n\n这个方法是上个方法的补充，也是动态加载实例方法。\n\nSEL sel　=　NSSelectorFromString(@\"doSomethingMethod:\")//注意这个冒号,说明方法带有参数\n\nif([object　respondsToSelector:sel]) {\n\n[object　performSelector:sel　withObject:color]; //注意如果有两个参数,使用两个withObject:参数;\n\n}\n\n### isKindOfClass\n\nisKindOfClass 我们也可以使用isKindOfClass来检查一个对象是否是一个类的成员\n\n### isMemberOfClass\n\nisMemberOfClass方法是来确定对象是否是某一个类的成员\n\n### initWithCoder和initWithFrame的区别　\n\ninitWithCoder是一个类在IB中创建但在xocdde中被实例化时被调用的.比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用.\n\ninitWithFrame是由用户创建的UIView子类，实例时被调用\n\n### UIView autoresizingMask\n\n如果视图的autoresizesSubviews属性声明被设置为YES，则其子视图会根据autoresizingMask属性的值自动进行尺寸调整。简单配置一下视图的自动尺寸调整掩码常常就能使应用程序得到合适的行为；否则，应用程序就必须通过重载layoutSubviews方法来提供自己的实现。\n\nself.autoresizingMask = UIViewAutoresizingFlexibleWidth;//这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。\n\nUIViewAutoresizingNone\n\n这个常量如果被设置，视图将不进行自动尺寸调整。\n\nUIViewAutoresizingFlexibleHeight\n\n这个常量如果被设置，视图的高度将和父视图的高度一起成比例变化。否则，视图的高度将保持不变。\n\nUIViewAutoresizingFlexibleWidth\n\n这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。\n\nUIViewAutoresizingFlexibleLeftMargin\n\n这个常量如果被设置，视图的左边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的左边界的相对位置将保持不变。\n\nUIViewAutoresizingFlexibleRightMargin\n\n这个常量如果被设置，视图的右边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的右边界的相对位置将保持不变。\n\nUIViewAutoresizingFlexibleBottomMargin\n\n这个常量如果被设置，视图的底边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的底边界的相对位置将保持不变。\n\nUIViewAutoresizingFlexibleTopMargin\n\n这个常量如果被设置，视图的上边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的上边界的相对位置将保持不变。\n\n","source":"_posts/NSClassFromString-NSSelectorFromString/NSClassFromString-NSSelectorFromString.md","raw":"---\ntitle: 'NSClassFromString,NSSelectorFromString...'\ndate: 2017-07-06 16:58:02\ntags:\n   - 技术\n---\n\n###  NSClassFromString\n\n这个方法判断类是否存在，如果存在就动态加载的，不存为就返回一个空对象;\n\nid myObj = [[NSClassFromString(@\"MyClass\") alloc] init];\n\n正常情况下等价于：id myObj = [[MyClass alloc] init];\n\n<!-- more -->\n优点：\n\n1， 弱化连接，因此并不会把没有的Framework也link到程序中。\n\n2，不需要使用import，因为类是动态加载的，只要存在就可以加载。因此如果你的toolchain中没有某个类的头文件定义，而你确信这个类是可以用的，那么也可以用这种方法。\n\n### NSSelectorFromString\n\n这个方法是上个方法的补充，也是动态加载实例方法。\n\nSEL sel　=　NSSelectorFromString(@\"doSomethingMethod:\")//注意这个冒号,说明方法带有参数\n\nif([object　respondsToSelector:sel]) {\n\n[object　performSelector:sel　withObject:color]; //注意如果有两个参数,使用两个withObject:参数;\n\n}\n\n### isKindOfClass\n\nisKindOfClass 我们也可以使用isKindOfClass来检查一个对象是否是一个类的成员\n\n### isMemberOfClass\n\nisMemberOfClass方法是来确定对象是否是某一个类的成员\n\n### initWithCoder和initWithFrame的区别　\n\ninitWithCoder是一个类在IB中创建但在xocdde中被实例化时被调用的.比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用.\n\ninitWithFrame是由用户创建的UIView子类，实例时被调用\n\n### UIView autoresizingMask\n\n如果视图的autoresizesSubviews属性声明被设置为YES，则其子视图会根据autoresizingMask属性的值自动进行尺寸调整。简单配置一下视图的自动尺寸调整掩码常常就能使应用程序得到合适的行为；否则，应用程序就必须通过重载layoutSubviews方法来提供自己的实现。\n\nself.autoresizingMask = UIViewAutoresizingFlexibleWidth;//这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。\n\nUIViewAutoresizingNone\n\n这个常量如果被设置，视图将不进行自动尺寸调整。\n\nUIViewAutoresizingFlexibleHeight\n\n这个常量如果被设置，视图的高度将和父视图的高度一起成比例变化。否则，视图的高度将保持不变。\n\nUIViewAutoresizingFlexibleWidth\n\n这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。\n\nUIViewAutoresizingFlexibleLeftMargin\n\n这个常量如果被设置，视图的左边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的左边界的相对位置将保持不变。\n\nUIViewAutoresizingFlexibleRightMargin\n\n这个常量如果被设置，视图的右边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的右边界的相对位置将保持不变。\n\nUIViewAutoresizingFlexibleBottomMargin\n\n这个常量如果被设置，视图的底边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的底边界的相对位置将保持不变。\n\nUIViewAutoresizingFlexibleTopMargin\n\n这个常量如果被设置，视图的上边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的上边界的相对位置将保持不变。\n\n","slug":"NSClassFromString-NSSelectorFromString/NSClassFromString-NSSelectorFromString","published":1,"updated":"2017-07-06T09:01:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xm00019yho1678lgom","content":"<h3 id=\"NSClassFromString\"><a href=\"#NSClassFromString\" class=\"headerlink\" title=\"NSClassFromString\"></a>NSClassFromString</h3><p>这个方法判断类是否存在，如果存在就动态加载的，不存为就返回一个空对象;</p>\n<p>id myObj = [[NSClassFromString(@”MyClass”) alloc] init];</p>\n<p>正常情况下等价于：id myObj = [[MyClass alloc] init];</p>\n<a id=\"more\"></a>\n<p>优点：</p>\n<p>1， 弱化连接，因此并不会把没有的Framework也link到程序中。</p>\n<p>2，不需要使用import，因为类是动态加载的，只要存在就可以加载。因此如果你的toolchain中没有某个类的头文件定义，而你确信这个类是可以用的，那么也可以用这种方法。</p>\n<h3 id=\"NSSelectorFromString\"><a href=\"#NSSelectorFromString\" class=\"headerlink\" title=\"NSSelectorFromString\"></a>NSSelectorFromString</h3><p>这个方法是上个方法的补充，也是动态加载实例方法。</p>\n<p>SEL sel　=　NSSelectorFromString(@”doSomethingMethod:”)//注意这个冒号,说明方法带有参数</p>\n<p>if([object　respondsToSelector:sel]) {</p>\n<p>[object　performSelector:sel　withObject:color]; //注意如果有两个参数,使用两个withObject:参数;</p>\n<p>}</p>\n<h3 id=\"isKindOfClass\"><a href=\"#isKindOfClass\" class=\"headerlink\" title=\"isKindOfClass\"></a>isKindOfClass</h3><p>isKindOfClass 我们也可以使用isKindOfClass来检查一个对象是否是一个类的成员</p>\n<h3 id=\"isMemberOfClass\"><a href=\"#isMemberOfClass\" class=\"headerlink\" title=\"isMemberOfClass\"></a>isMemberOfClass</h3><p>isMemberOfClass方法是来确定对象是否是某一个类的成员</p>\n<h3 id=\"initWithCoder和initWithFrame的区别\"><a href=\"#initWithCoder和initWithFrame的区别\" class=\"headerlink\" title=\"initWithCoder和initWithFrame的区别　\"></a>initWithCoder和initWithFrame的区别　</h3><p>initWithCoder是一个类在IB中创建但在xocdde中被实例化时被调用的.比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用.</p>\n<p>initWithFrame是由用户创建的UIView子类，实例时被调用</p>\n<h3 id=\"UIView-autoresizingMask\"><a href=\"#UIView-autoresizingMask\" class=\"headerlink\" title=\"UIView autoresizingMask\"></a>UIView autoresizingMask</h3><p>如果视图的autoresizesSubviews属性声明被设置为YES，则其子视图会根据autoresizingMask属性的值自动进行尺寸调整。简单配置一下视图的自动尺寸调整掩码常常就能使应用程序得到合适的行为；否则，应用程序就必须通过重载layoutSubviews方法来提供自己的实现。</p>\n<p>self.autoresizingMask = UIViewAutoresizingFlexibleWidth;//这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。</p>\n<p>UIViewAutoresizingNone</p>\n<p>这个常量如果被设置，视图将不进行自动尺寸调整。</p>\n<p>UIViewAutoresizingFlexibleHeight</p>\n<p>这个常量如果被设置，视图的高度将和父视图的高度一起成比例变化。否则，视图的高度将保持不变。</p>\n<p>UIViewAutoresizingFlexibleWidth</p>\n<p>这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。</p>\n<p>UIViewAutoresizingFlexibleLeftMargin</p>\n<p>这个常量如果被设置，视图的左边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的左边界的相对位置将保持不变。</p>\n<p>UIViewAutoresizingFlexibleRightMargin</p>\n<p>这个常量如果被设置，视图的右边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的右边界的相对位置将保持不变。</p>\n<p>UIViewAutoresizingFlexibleBottomMargin</p>\n<p>这个常量如果被设置，视图的底边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的底边界的相对位置将保持不变。</p>\n<p>UIViewAutoresizingFlexibleTopMargin</p>\n<p>这个常量如果被设置，视图的上边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的上边界的相对位置将保持不变。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"NSClassFromString\"><a href=\"#NSClassFromString\" class=\"headerlink\" title=\"NSClassFromString\"></a>NSClassFromString</h3><p>这个方法判断类是否存在，如果存在就动态加载的，不存为就返回一个空对象;</p>\n<p>id myObj = [[NSClassFromString(@”MyClass”) alloc] init];</p>\n<p>正常情况下等价于：id myObj = [[MyClass alloc] init];</p>","more":"<p>优点：</p>\n<p>1， 弱化连接，因此并不会把没有的Framework也link到程序中。</p>\n<p>2，不需要使用import，因为类是动态加载的，只要存在就可以加载。因此如果你的toolchain中没有某个类的头文件定义，而你确信这个类是可以用的，那么也可以用这种方法。</p>\n<h3 id=\"NSSelectorFromString\"><a href=\"#NSSelectorFromString\" class=\"headerlink\" title=\"NSSelectorFromString\"></a>NSSelectorFromString</h3><p>这个方法是上个方法的补充，也是动态加载实例方法。</p>\n<p>SEL sel　=　NSSelectorFromString(@”doSomethingMethod:”)//注意这个冒号,说明方法带有参数</p>\n<p>if([object　respondsToSelector:sel]) {</p>\n<p>[object　performSelector:sel　withObject:color]; //注意如果有两个参数,使用两个withObject:参数;</p>\n<p>}</p>\n<h3 id=\"isKindOfClass\"><a href=\"#isKindOfClass\" class=\"headerlink\" title=\"isKindOfClass\"></a>isKindOfClass</h3><p>isKindOfClass 我们也可以使用isKindOfClass来检查一个对象是否是一个类的成员</p>\n<h3 id=\"isMemberOfClass\"><a href=\"#isMemberOfClass\" class=\"headerlink\" title=\"isMemberOfClass\"></a>isMemberOfClass</h3><p>isMemberOfClass方法是来确定对象是否是某一个类的成员</p>\n<h3 id=\"initWithCoder和initWithFrame的区别\"><a href=\"#initWithCoder和initWithFrame的区别\" class=\"headerlink\" title=\"initWithCoder和initWithFrame的区别　\"></a>initWithCoder和initWithFrame的区别　</h3><p>initWithCoder是一个类在IB中创建但在xocdde中被实例化时被调用的.比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用.</p>\n<p>initWithFrame是由用户创建的UIView子类，实例时被调用</p>\n<h3 id=\"UIView-autoresizingMask\"><a href=\"#UIView-autoresizingMask\" class=\"headerlink\" title=\"UIView autoresizingMask\"></a>UIView autoresizingMask</h3><p>如果视图的autoresizesSubviews属性声明被设置为YES，则其子视图会根据autoresizingMask属性的值自动进行尺寸调整。简单配置一下视图的自动尺寸调整掩码常常就能使应用程序得到合适的行为；否则，应用程序就必须通过重载layoutSubviews方法来提供自己的实现。</p>\n<p>self.autoresizingMask = UIViewAutoresizingFlexibleWidth;//这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。</p>\n<p>UIViewAutoresizingNone</p>\n<p>这个常量如果被设置，视图将不进行自动尺寸调整。</p>\n<p>UIViewAutoresizingFlexibleHeight</p>\n<p>这个常量如果被设置，视图的高度将和父视图的高度一起成比例变化。否则，视图的高度将保持不变。</p>\n<p>UIViewAutoresizingFlexibleWidth</p>\n<p>这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。</p>\n<p>UIViewAutoresizingFlexibleLeftMargin</p>\n<p>这个常量如果被设置，视图的左边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的左边界的相对位置将保持不变。</p>\n<p>UIViewAutoresizingFlexibleRightMargin</p>\n<p>这个常量如果被设置，视图的右边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的右边界的相对位置将保持不变。</p>\n<p>UIViewAutoresizingFlexibleBottomMargin</p>\n<p>这个常量如果被设置，视图的底边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的底边界的相对位置将保持不变。</p>\n<p>UIViewAutoresizingFlexibleTopMargin</p>\n<p>这个常量如果被设置，视图的上边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的上边界的相对位置将保持不变。</p>"},{"title":"button横向自动排布的几种方式","date":"2017-07-06T10:44:13.000Z","_content":"\n### 第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\n\n<!-- more -->\n\n\t{for (int i=0; i<_dataSources.count; i++) {\n\n\tNSInteger rowCount = 0;\n\n\tif (SCREENWIDTH >320) {\n\n\trowCount =(SCREENWIDTH - 46)/90 + 1;\n\n\t}else{\n\n\trowCount =(SCREENWIDTH - 46)/90;\n\n\t}\n\n\tUIButton *perButton = [[UIButton alloc]init];\n\n\tperButton.tag = i+100;\n\n\t[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\n\tperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n\t[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\n\tperButton.layer.cornerRadius = 5;\n\n\tperButton.layer.masksToBounds = YES;\n\n\t[self addSubview:perButton];\n\n\tif (i<=(rowCount -1)) {\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\n\tif (i== 0) {\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);\n\n\t}else if(i> 0 && i<= rowCount - 1){\n\n\tmake.left.mas_equalTo(i*93 + 23);\n\n\t}\n\n\tmake.width.mas_equalTo(70);\n\n\tmake.height.mas_equalTo(34);\n\n\t}];\n\n\tif (i == rowCount - 1 ) {\n\n\t_signCount = i;\n\n\t}\n\n\t}else if(i>(rowCount-1)){\n\n\tUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\n\tif(i%rowCount == 0){\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);\n\n\t}\n\n\telse if(i%rowCount > 0){\n\n\tmake.left.mas_equalTo((i%rowCount)*93 + 23);\n\n\t}\n\n\tmake.width.mas_equalTo(70);\n\n\tmake.height.mas_equalTo(32);\n\n\t}];\n\n\tif (SCREENWIDTH > 320 && i%rowCount == 3) {\n\n\t_signCount = i;\n\n\t}else if(SCREENWIDTH == 320 && i%rowCount == 2){\n\n\t_signCount = i;\n\n\t}\n\n\t}\n\n\t}\n\t}\n\t\n### 第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\n\n\t{for (int i=0; i<_dataSources.count; i++) {\n\n\tNSInteger rowCount =3;\n\n\tUIButton *perButton = [[UIButton alloc]init];\n\n\tperButton.tag = i+100;\n\n\t[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\n\tperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n\t[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\n\tperButton.layer.cornerRadius = 5;\n\n\tperButton.layer.masksToBounds = YES;\n\n\t[self addSubview:perButton];\n\n\tif (i<=(rowCount -1)) {\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\n\tif (i== 0) {\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);//(/3/2)\n\n\t}else if(i == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n\t}else if(i == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-23);\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(34);\n\n\t}];\n\n\tif (i == rowCount - 1 ) {\n\n\t_signCount = i;\n\n\t}\n\n\t}else if(i>(rowCount-1)){\n\n\tUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\n\tif(i%rowCount == 0){\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);\n\n\t}\n\n\telse if(i%rowCount == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n\t}else if(i%rowCount == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-23);\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(32);\n\n\t}];\n\n\tif(i%rowCount == 2){\n\n\t_signCount = i;\n\t\n\t}\n\n\t}\n\n\t}\n\t}\n\n### 第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:\n\n\t{for (int i=0; i<_dataSources.count; i++) {\n\n\tNSInteger rowCount =3;\n\n\tUIButton *perButton = [[UIButton alloc]init];\n\n\tperButton.tag = i+100;\n\n\t[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\n\tperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n\t[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\n\tperButton.layer.cornerRadius = 5;\n\n\tperButton.layer.masksToBounds = YES;\n\n\t[self addSubview:perButton];\n\n\tif (i<=(rowCount -1)) {\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\n\tif (i== 0) {\n\n\tmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);//(/3/2)\n\n\t}else if(i == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n\t}else if(i == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(34);\n\n\t}];\n\n\tif (i == rowCount - 1 ) {\n\n\t_signCount = i;\n\n\t}\n\n\t}else if(i>(rowCount-1)){\n\n\tUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\n\tif(i%rowCount == 0){\n\n\tmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);                }\n\n\telse if(i%rowCount == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n\t}else if(i%rowCount == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(32);\n\n\t}];\n\n\tif(i%rowCount == 2){\n\n\t_signCount = i;\n\n\t}\n\n\t}\n\n\t}\n\n\t}","source":"_posts/button横向自动排布的几种方式/button横向自动排布的几种方式.md","raw":"---\ntitle: button横向自动排布的几种方式\ndate: 2017-07-06 18:44:13\ntags:\n---\n\n### 第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\n\n<!-- more -->\n\n\t{for (int i=0; i<_dataSources.count; i++) {\n\n\tNSInteger rowCount = 0;\n\n\tif (SCREENWIDTH >320) {\n\n\trowCount =(SCREENWIDTH - 46)/90 + 1;\n\n\t}else{\n\n\trowCount =(SCREENWIDTH - 46)/90;\n\n\t}\n\n\tUIButton *perButton = [[UIButton alloc]init];\n\n\tperButton.tag = i+100;\n\n\t[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\n\tperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n\t[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\n\tperButton.layer.cornerRadius = 5;\n\n\tperButton.layer.masksToBounds = YES;\n\n\t[self addSubview:perButton];\n\n\tif (i<=(rowCount -1)) {\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\n\tif (i== 0) {\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);\n\n\t}else if(i> 0 && i<= rowCount - 1){\n\n\tmake.left.mas_equalTo(i*93 + 23);\n\n\t}\n\n\tmake.width.mas_equalTo(70);\n\n\tmake.height.mas_equalTo(34);\n\n\t}];\n\n\tif (i == rowCount - 1 ) {\n\n\t_signCount = i;\n\n\t}\n\n\t}else if(i>(rowCount-1)){\n\n\tUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\n\tif(i%rowCount == 0){\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);\n\n\t}\n\n\telse if(i%rowCount > 0){\n\n\tmake.left.mas_equalTo((i%rowCount)*93 + 23);\n\n\t}\n\n\tmake.width.mas_equalTo(70);\n\n\tmake.height.mas_equalTo(32);\n\n\t}];\n\n\tif (SCREENWIDTH > 320 && i%rowCount == 3) {\n\n\t_signCount = i;\n\n\t}else if(SCREENWIDTH == 320 && i%rowCount == 2){\n\n\t_signCount = i;\n\n\t}\n\n\t}\n\n\t}\n\t}\n\t\n### 第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\n\n\t{for (int i=0; i<_dataSources.count; i++) {\n\n\tNSInteger rowCount =3;\n\n\tUIButton *perButton = [[UIButton alloc]init];\n\n\tperButton.tag = i+100;\n\n\t[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\n\tperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n\t[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\n\tperButton.layer.cornerRadius = 5;\n\n\tperButton.layer.masksToBounds = YES;\n\n\t[self addSubview:perButton];\n\n\tif (i<=(rowCount -1)) {\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\n\tif (i== 0) {\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);//(/3/2)\n\n\t}else if(i == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n\t}else if(i == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-23);\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(34);\n\n\t}];\n\n\tif (i == rowCount - 1 ) {\n\n\t_signCount = i;\n\n\t}\n\n\t}else if(i>(rowCount-1)){\n\n\tUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\n\tif(i%rowCount == 0){\n\n\tmake.left.equalTo(self.mas_left).with.offset(23);\n\n\t}\n\n\telse if(i%rowCount == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n\t}else if(i%rowCount == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-23);\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(32);\n\n\t}];\n\n\tif(i%rowCount == 2){\n\n\t_signCount = i;\n\t\n\t}\n\n\t}\n\n\t}\n\t}\n\n### 第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:\n\n\t{for (int i=0; i<_dataSources.count; i++) {\n\n\tNSInteger rowCount =3;\n\n\tUIButton *perButton = [[UIButton alloc]init];\n\n\tperButton.tag = i+100;\n\n\t[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\n\tperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n\t[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\n\tperButton.layer.cornerRadius = 5;\n\n\tperButton.layer.masksToBounds = YES;\n\n\t[self addSubview:perButton];\n\n\tif (i<=(rowCount -1)) {\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\n\tif (i== 0) {\n\n\tmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);//(/3/2)\n\n\t}else if(i == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n\t}else if(i == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(34);\n\n\t}];\n\n\tif (i == rowCount - 1 ) {\n\n\t_signCount = i;\n\n\t}\n\n\t}else if(i>(rowCount-1)){\n\n\tUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n\t[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\n\tmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\n\tif(i%rowCount == 0){\n\n\tmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);                }\n\n\telse if(i%rowCount == 1){\n\n\tmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n\t}else if(i%rowCount == 2){\n\n\tmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n\t}\n\n\tmake.width.mas_equalTo(72);\n\n\tmake.height.mas_equalTo(32);\n\n\t}];\n\n\tif(i%rowCount == 2){\n\n\t_signCount = i;\n\n\t}\n\n\t}\n\n\t}\n\n\t}","slug":"button横向自动排布的几种方式/button横向自动排布的几种方式","published":1,"updated":"2017-07-06T10:50:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xq00039yhorfrjhr5v","content":"<h3 id=\"第一种方式-根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\"><a href=\"#第一种方式-根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\" class=\"headerlink\" title=\"第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\"></a>第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布</h3><a id=\"more\"></a>\n<pre><code>{for (int i=0; i&lt;_dataSources.count; i++) {\n\nNSInteger rowCount = 0;\n\nif (SCREENWIDTH &gt;320) {\n\nrowCount =(SCREENWIDTH - 46)/90 + 1;\n\n}else{\n\nrowCount =(SCREENWIDTH - 46)/90;\n\n}\n\nUIButton *perButton = [[UIButton alloc]init];\n\nperButton.tag = i+100;\n\n[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\nperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\nperButton.layer.cornerRadius = 5;\n\nperButton.layer.masksToBounds = YES;\n\n[self addSubview:perButton];\n\nif (i&lt;=(rowCount -1)) {\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\nif (i== 0) {\n\nmake.left.equalTo(self.mas_left).with.offset(23);\n\n}else if(i&gt; 0 &amp;&amp; i&lt;= rowCount - 1){\n\nmake.left.mas_equalTo(i*93 + 23);\n\n}\n\nmake.width.mas_equalTo(70);\n\nmake.height.mas_equalTo(34);\n\n}];\n\nif (i == rowCount - 1 ) {\n\n_signCount = i;\n\n}\n\n}else if(i&gt;(rowCount-1)){\n\nUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\nif(i%rowCount == 0){\n\nmake.left.equalTo(self.mas_left).with.offset(23);\n\n}\n\nelse if(i%rowCount &gt; 0){\n\nmake.left.mas_equalTo((i%rowCount)*93 + 23);\n\n}\n\nmake.width.mas_equalTo(70);\n\nmake.height.mas_equalTo(32);\n\n}];\n\nif (SCREENWIDTH &gt; 320 &amp;&amp; i%rowCount == 3) {\n\n_signCount = i;\n\n}else if(SCREENWIDTH == 320 &amp;&amp; i%rowCount == 2){\n\n_signCount = i;\n\n}\n\n}\n\n}\n}\n</code></pre><h3 id=\"第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\"><a href=\"#第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\" class=\"headerlink\" title=\"第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\"></a>第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：</h3><pre><code>{for (int i=0; i&lt;_dataSources.count; i++) {\n\nNSInteger rowCount =3;\n\nUIButton *perButton = [[UIButton alloc]init];\n\nperButton.tag = i+100;\n\n[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\nperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\nperButton.layer.cornerRadius = 5;\n\nperButton.layer.masksToBounds = YES;\n\n[self addSubview:perButton];\n\nif (i&lt;=(rowCount -1)) {\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\nif (i== 0) {\n\nmake.left.equalTo(self.mas_left).with.offset(23);//(/3/2)\n\n}else if(i == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n}else if(i == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-23);\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(34);\n\n}];\n\nif (i == rowCount - 1 ) {\n\n_signCount = i;\n\n}\n\n}else if(i&gt;(rowCount-1)){\n\nUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\nif(i%rowCount == 0){\n\nmake.left.equalTo(self.mas_left).with.offset(23);\n\n}\n\nelse if(i%rowCount == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n}else if(i%rowCount == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-23);\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(32);\n\n}];\n\nif(i%rowCount == 2){\n\n_signCount = i;\n\n}\n\n}\n\n}\n}\n</code></pre><h3 id=\"第三种-确定好第一排能放多少个，然后设置没一个间隙的间距都相同\"><a href=\"#第三种-确定好第一排能放多少个，然后设置没一个间隙的间距都相同\" class=\"headerlink\" title=\"第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:\"></a>第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:</h3><pre><code>{for (int i=0; i&lt;_dataSources.count; i++) {\n\nNSInteger rowCount =3;\n\nUIButton *perButton = [[UIButton alloc]init];\n\nperButton.tag = i+100;\n\n[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\nperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\nperButton.layer.cornerRadius = 5;\n\nperButton.layer.masksToBounds = YES;\n\n[self addSubview:perButton];\n\nif (i&lt;=(rowCount -1)) {\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\nif (i== 0) {\n\nmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);//(/3/2)\n\n}else if(i == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n}else if(i == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(34);\n\n}];\n\nif (i == rowCount - 1 ) {\n\n_signCount = i;\n\n}\n\n}else if(i&gt;(rowCount-1)){\n\nUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\nif(i%rowCount == 0){\n\nmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);                }\n\nelse if(i%rowCount == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n}else if(i%rowCount == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(32);\n\n}];\n\nif(i%rowCount == 2){\n\n_signCount = i;\n\n}\n\n}\n\n}\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"第一种方式-根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\"><a href=\"#第一种方式-根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\" class=\"headerlink\" title=\"第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布\"></a>第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布</h3>","more":"<pre><code>{for (int i=0; i&lt;_dataSources.count; i++) {\n\nNSInteger rowCount = 0;\n\nif (SCREENWIDTH &gt;320) {\n\nrowCount =(SCREENWIDTH - 46)/90 + 1;\n\n}else{\n\nrowCount =(SCREENWIDTH - 46)/90;\n\n}\n\nUIButton *perButton = [[UIButton alloc]init];\n\nperButton.tag = i+100;\n\n[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\nperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\nperButton.layer.cornerRadius = 5;\n\nperButton.layer.masksToBounds = YES;\n\n[self addSubview:perButton];\n\nif (i&lt;=(rowCount -1)) {\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\nif (i== 0) {\n\nmake.left.equalTo(self.mas_left).with.offset(23);\n\n}else if(i&gt; 0 &amp;&amp; i&lt;= rowCount - 1){\n\nmake.left.mas_equalTo(i*93 + 23);\n\n}\n\nmake.width.mas_equalTo(70);\n\nmake.height.mas_equalTo(34);\n\n}];\n\nif (i == rowCount - 1 ) {\n\n_signCount = i;\n\n}\n\n}else if(i&gt;(rowCount-1)){\n\nUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\nif(i%rowCount == 0){\n\nmake.left.equalTo(self.mas_left).with.offset(23);\n\n}\n\nelse if(i%rowCount &gt; 0){\n\nmake.left.mas_equalTo((i%rowCount)*93 + 23);\n\n}\n\nmake.width.mas_equalTo(70);\n\nmake.height.mas_equalTo(32);\n\n}];\n\nif (SCREENWIDTH &gt; 320 &amp;&amp; i%rowCount == 3) {\n\n_signCount = i;\n\n}else if(SCREENWIDTH == 320 &amp;&amp; i%rowCount == 2){\n\n_signCount = i;\n\n}\n\n}\n\n}\n}\n</code></pre><h3 id=\"第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\"><a href=\"#第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\" class=\"headerlink\" title=\"第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：\"></a>第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：</h3><pre><code>{for (int i=0; i&lt;_dataSources.count; i++) {\n\nNSInteger rowCount =3;\n\nUIButton *perButton = [[UIButton alloc]init];\n\nperButton.tag = i+100;\n\n[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\nperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\nperButton.layer.cornerRadius = 5;\n\nperButton.layer.masksToBounds = YES;\n\n[self addSubview:perButton];\n\nif (i&lt;=(rowCount -1)) {\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\nif (i== 0) {\n\nmake.left.equalTo(self.mas_left).with.offset(23);//(/3/2)\n\n}else if(i == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n}else if(i == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-23);\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(34);\n\n}];\n\nif (i == rowCount - 1 ) {\n\n_signCount = i;\n\n}\n\n}else if(i&gt;(rowCount-1)){\n\nUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\nif(i%rowCount == 0){\n\nmake.left.equalTo(self.mas_left).with.offset(23);\n\n}\n\nelse if(i%rowCount == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2);\n\n}else if(i%rowCount == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-23);\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(32);\n\n}];\n\nif(i%rowCount == 2){\n\n_signCount = i;\n\n}\n\n}\n\n}\n}\n</code></pre><h3 id=\"第三种-确定好第一排能放多少个，然后设置没一个间隙的间距都相同\"><a href=\"#第三种-确定好第一排能放多少个，然后设置没一个间隙的间距都相同\" class=\"headerlink\" title=\"第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:\"></a>第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:</h3><pre><code>{for (int i=0; i&lt;_dataSources.count; i++) {\n\nNSInteger rowCount =3;\n\nUIButton *perButton = [[UIButton alloc]init];\n\nperButton.tag = i+100;\n\n[perButton setTitle:_dataSources[i] forState:UIControlStateNormal];\n\nperButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1);\n\n[perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];\n\nperButton.layer.cornerRadius = 5;\n\nperButton.layer.masksToBounds = YES;\n\n[self addSubview:perButton];\n\nif (i&lt;=(rowCount -1)) {\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23);\n\nif (i== 0) {\n\nmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);//(/3/2)\n\n}else if(i == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n}else if(i == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(34);\n\n}];\n\nif (i == rowCount - 1 ) {\n\n_signCount = i;\n\n}\n\n}else if(i&gt;(rowCount-1)){\n\nUIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100];\n\n[perButton mas_makeConstraints:^(MASConstraintMaker *make) {\n\nmake.top.equalTo(topButton.mas_bottom).with.offset(15);\n\nif(i%rowCount == 0){\n\nmake.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);                }\n\nelse if(i%rowCount == 1){\n\nmake.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2);\n\n}else if(i%rowCount == 2){\n\nmake.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4));\n\n}\n\nmake.width.mas_equalTo(72);\n\nmake.height.mas_equalTo(32);\n\n}];\n\nif(i%rowCount == 2){\n\n_signCount = i;\n\n}\n\n}\n\n}\n\n}\n</code></pre>"},{"title":"如何填补友盟分享新浪微博的那些坑","date":"2017-07-06T10:51:15.000Z","_content":"\n前端时间听人说友盟分享更加简单、专业一些，然后我就开始尝试通过友盟来写一个分享的demo，因为，新浪微博分享是不要真机测试也能进行分享的，所以，在毫不知情的情况下，慢慢的就走进了那些坑。\n\n 废话不多说，现在把怎样实现一个新浪微博的分享给大家演示一遍。希望能给后面的童鞋起到一起抛砖引玉的效果。\n \n <!-- more -->\n \n 一：首先，友盟分享要想成功，你得导入像QQ、微信、新浪微博、短信等第三方的白名单，我一开始就是被这个给坑了，拿着友盟的官方文档和demo，就开始埋头苦干，结果就是打死也分享不成功，到处问别人，才听说有要加白名单这回事，这才找到了文档加白名单的地方。\n\n下面那个就是友盟分享文档加白名单的地方，你只需要按照他上面的提示把你的info.plist文件以source.code的形式打开，再把那些白名单加进去就行了。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-e5c934d55c4d82fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然，加入白名单以后，你就算是过了第一关，跳过了一个坑。这个时候，如果你想要给自己的APP瘦身的话，你按照下面的方式去操作\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-df9256d78dae125a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好，已经过了一关了，想想是不是有点小激动，不过，不要太开心，这只是一个开始。接下来我们就要开始进行新浪微博的分享了，首先你如果想要进行新浪微博的分享，那你就必须得到新浪的官网去注册一个应用的appkey 和appsecret,登录网址：http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！\n\n这些工作完成以后，我们就要导入友盟的分享的SDK了，话不用说，大家都应该知道有两种方法（手动导入、cocoaPods导入）你只需要选择其中一种就好了。两种方法我都试过了，这里我推荐使用cocoaPods来导入，这样不用自己去配置那些链接库啥的，不容易出错。\n\n通过cocoaPods导入，首先在你终端中今日你分享项目的目录并且查询友盟分享当前有那些版本:\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-f9d0aa966c311156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在这么多版本中你要选择比较新的一个版本，我是选择的4.3这个版本，然后我们就可以在vim中去配置关于友盟的信息：\n![image](http://upload-images.jianshu.io/upload_images/1863813-9d2c6ee717f20e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后再安装4.3版本的友盟分享SDK，只要出现了complete就表示完成了。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-c967fcba2f2cb3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个时候，我们再到AppDelegate.m文件中加上两个头文件\n\n #import \"UMSocial.h\"  ---->这个头文件是关于友盟的\n\n #import \"UMSocialSinaSSOHandler.h\" ----->这个头文件是关于新浪微博的\n\n下面的appkey对应什么意思都有代码，照着这样写就行了。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-3911b9688887554c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们在处理新浪微博SSO授权以及微信分享完成以后还要跳转回当前app来，所以还要加入下面两端代码\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-211ebe5c6b90c561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在这里，你还得在你项目的info->URL Types里面添加一个URL Schemes进去\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-0f1fd0ac85eefb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n添加完上面的代码，AppDelegate.m里面的代码算是全部写完了，现在你只需要集成分享功能的视图源码UIViewController.m，把如下代码复制并粘贴到你将弹出一个分享列表的位置后面，例如到响应分享按钮的方法中调用它。并且修改下面的友盟appkey，你要分享的文字、图片，你要分享到的微博平台，例如下面写的是新浪微博、腾讯微博、人人网。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-e392053e01ad3242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你如果还想要知道你是否分享成功，你还可以调用以下方法\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-06bd9e8712d00d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到这里，基本上一个完整的新浪微博分享就成功了，但是还有一个最大的坑等着你去填呢，我花了好久才解决的就是这个大坑。因为新浪微博注册的时候你要上传你的app的bundle id，所以你当前项目的bundle id必须跟你申请新浪微博的bundle id一致，不然的话，就会发生分享授权不成功，出现闪退的现象。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-b7c1a4b45cacd321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/如何填补友盟分享新浪微博的那些坑/如何填补友盟分享新浪微博的那些坑.md","raw":"---\ntitle: 如何填补友盟分享新浪微博的那些坑\ndate: 2017-07-06 18:51:15\ntags:\n  - 分享\n  - 第三方\n---\n\n前端时间听人说友盟分享更加简单、专业一些，然后我就开始尝试通过友盟来写一个分享的demo，因为，新浪微博分享是不要真机测试也能进行分享的，所以，在毫不知情的情况下，慢慢的就走进了那些坑。\n\n 废话不多说，现在把怎样实现一个新浪微博的分享给大家演示一遍。希望能给后面的童鞋起到一起抛砖引玉的效果。\n \n <!-- more -->\n \n 一：首先，友盟分享要想成功，你得导入像QQ、微信、新浪微博、短信等第三方的白名单，我一开始就是被这个给坑了，拿着友盟的官方文档和demo，就开始埋头苦干，结果就是打死也分享不成功，到处问别人，才听说有要加白名单这回事，这才找到了文档加白名单的地方。\n\n下面那个就是友盟分享文档加白名单的地方，你只需要按照他上面的提示把你的info.plist文件以source.code的形式打开，再把那些白名单加进去就行了。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-e5c934d55c4d82fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然，加入白名单以后，你就算是过了第一关，跳过了一个坑。这个时候，如果你想要给自己的APP瘦身的话，你按照下面的方式去操作\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-df9256d78dae125a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好，已经过了一关了，想想是不是有点小激动，不过，不要太开心，这只是一个开始。接下来我们就要开始进行新浪微博的分享了，首先你如果想要进行新浪微博的分享，那你就必须得到新浪的官网去注册一个应用的appkey 和appsecret,登录网址：http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！\n\n这些工作完成以后，我们就要导入友盟的分享的SDK了，话不用说，大家都应该知道有两种方法（手动导入、cocoaPods导入）你只需要选择其中一种就好了。两种方法我都试过了，这里我推荐使用cocoaPods来导入，这样不用自己去配置那些链接库啥的，不容易出错。\n\n通过cocoaPods导入，首先在你终端中今日你分享项目的目录并且查询友盟分享当前有那些版本:\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-f9d0aa966c311156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在这么多版本中你要选择比较新的一个版本，我是选择的4.3这个版本，然后我们就可以在vim中去配置关于友盟的信息：\n![image](http://upload-images.jianshu.io/upload_images/1863813-9d2c6ee717f20e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后再安装4.3版本的友盟分享SDK，只要出现了complete就表示完成了。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-c967fcba2f2cb3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个时候，我们再到AppDelegate.m文件中加上两个头文件\n\n #import \"UMSocial.h\"  ---->这个头文件是关于友盟的\n\n #import \"UMSocialSinaSSOHandler.h\" ----->这个头文件是关于新浪微博的\n\n下面的appkey对应什么意思都有代码，照着这样写就行了。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-3911b9688887554c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们在处理新浪微博SSO授权以及微信分享完成以后还要跳转回当前app来，所以还要加入下面两端代码\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-211ebe5c6b90c561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在这里，你还得在你项目的info->URL Types里面添加一个URL Schemes进去\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-0f1fd0ac85eefb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n添加完上面的代码，AppDelegate.m里面的代码算是全部写完了，现在你只需要集成分享功能的视图源码UIViewController.m，把如下代码复制并粘贴到你将弹出一个分享列表的位置后面，例如到响应分享按钮的方法中调用它。并且修改下面的友盟appkey，你要分享的文字、图片，你要分享到的微博平台，例如下面写的是新浪微博、腾讯微博、人人网。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-e392053e01ad3242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你如果还想要知道你是否分享成功，你还可以调用以下方法\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-06bd9e8712d00d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到这里，基本上一个完整的新浪微博分享就成功了，但是还有一个最大的坑等着你去填呢，我花了好久才解决的就是这个大坑。因为新浪微博注册的时候你要上传你的app的bundle id，所以你当前项目的bundle id必须跟你申请新浪微博的bundle id一致，不然的话，就会发生分享授权不成功，出现闪退的现象。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-b7c1a4b45cacd321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"如何填补友盟分享新浪微博的那些坑/如何填补友盟分享新浪微博的那些坑","published":1,"updated":"2017-07-06T10:56:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xr00049yhox6xabsto","content":"<p>前端时间听人说友盟分享更加简单、专业一些，然后我就开始尝试通过友盟来写一个分享的demo，因为，新浪微博分享是不要真机测试也能进行分享的，所以，在毫不知情的情况下，慢慢的就走进了那些坑。</p>\n<p> 废话不多说，现在把怎样实现一个新浪微博的分享给大家演示一遍。希望能给后面的童鞋起到一起抛砖引玉的效果。</p>\n <a id=\"more\"></a>\n<p> 一：首先，友盟分享要想成功，你得导入像QQ、微信、新浪微博、短信等第三方的白名单，我一开始就是被这个给坑了，拿着友盟的官方文档和demo，就开始埋头苦干，结果就是打死也分享不成功，到处问别人，才听说有要加白名单这回事，这才找到了文档加白名单的地方。</p>\n<p>下面那个就是友盟分享文档加白名单的地方，你只需要按照他上面的提示把你的info.plist文件以source.code的形式打开，再把那些白名单加进去就行了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-e5c934d55c4d82fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>当然，加入白名单以后，你就算是过了第一关，跳过了一个坑。这个时候，如果你想要给自己的APP瘦身的话，你按照下面的方式去操作</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-df9256d78dae125a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>好，已经过了一关了，想想是不是有点小激动，不过，不要太开心，这只是一个开始。接下来我们就要开始进行新浪微博的分享了，首先你如果想要进行新浪微博的分享，那你就必须得到新浪的官网去注册一个应用的appkey 和appsecret,登录网址：<a href=\"http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！\" target=\"_blank\" rel=\"external\">http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！</a></p>\n<p>这些工作完成以后，我们就要导入友盟的分享的SDK了，话不用说，大家都应该知道有两种方法（手动导入、cocoaPods导入）你只需要选择其中一种就好了。两种方法我都试过了，这里我推荐使用cocoaPods来导入，这样不用自己去配置那些链接库啥的，不容易出错。</p>\n<p>通过cocoaPods导入，首先在你终端中今日你分享项目的目录并且查询友盟分享当前有那些版本:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-f9d0aa966c311156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在这么多版本中你要选择比较新的一个版本，我是选择的4.3这个版本，然后我们就可以在vim中去配置关于友盟的信息：<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9d2c6ee717f20e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后再安装4.3版本的友盟分享SDK，只要出现了complete就表示完成了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-c967fcba2f2cb3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>这个时候，我们再到AppDelegate.m文件中加上两个头文件</p>\n<p> #import “UMSocial.h”  —-&gt;这个头文件是关于友盟的</p>\n<p> #import “UMSocialSinaSSOHandler.h” —–&gt;这个头文件是关于新浪微博的</p>\n<p>下面的appkey对应什么意思都有代码，照着这样写就行了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3911b9688887554c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>我们在处理新浪微博SSO授权以及微信分享完成以后还要跳转回当前app来，所以还要加入下面两端代码</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-211ebe5c6b90c561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在这里，你还得在你项目的info-&gt;URL Types里面添加一个URL Schemes进去</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-0f1fd0ac85eefb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>添加完上面的代码，AppDelegate.m里面的代码算是全部写完了，现在你只需要集成分享功能的视图源码UIViewController.m，把如下代码复制并粘贴到你将弹出一个分享列表的位置后面，例如到响应分享按钮的方法中调用它。并且修改下面的友盟appkey，你要分享的文字、图片，你要分享到的微博平台，例如下面写的是新浪微博、腾讯微博、人人网。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-e392053e01ad3242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>你如果还想要知道你是否分享成功，你还可以调用以下方法</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-06bd9e8712d00d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>到这里，基本上一个完整的新浪微博分享就成功了，但是还有一个最大的坑等着你去填呢，我花了好久才解决的就是这个大坑。因为新浪微博注册的时候你要上传你的app的bundle id，所以你当前项目的bundle id必须跟你申请新浪微博的bundle id一致，不然的话，就会发生分享授权不成功，出现闪退的现象。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b7c1a4b45cacd321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<p>前端时间听人说友盟分享更加简单、专业一些，然后我就开始尝试通过友盟来写一个分享的demo，因为，新浪微博分享是不要真机测试也能进行分享的，所以，在毫不知情的情况下，慢慢的就走进了那些坑。</p>\n<p> 废话不多说，现在把怎样实现一个新浪微博的分享给大家演示一遍。希望能给后面的童鞋起到一起抛砖引玉的效果。</p>","more":"<p> 一：首先，友盟分享要想成功，你得导入像QQ、微信、新浪微博、短信等第三方的白名单，我一开始就是被这个给坑了，拿着友盟的官方文档和demo，就开始埋头苦干，结果就是打死也分享不成功，到处问别人，才听说有要加白名单这回事，这才找到了文档加白名单的地方。</p>\n<p>下面那个就是友盟分享文档加白名单的地方，你只需要按照他上面的提示把你的info.plist文件以source.code的形式打开，再把那些白名单加进去就行了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-e5c934d55c4d82fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>当然，加入白名单以后，你就算是过了第一关，跳过了一个坑。这个时候，如果你想要给自己的APP瘦身的话，你按照下面的方式去操作</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-df9256d78dae125a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>好，已经过了一关了，想想是不是有点小激动，不过，不要太开心，这只是一个开始。接下来我们就要开始进行新浪微博的分享了，首先你如果想要进行新浪微博的分享，那你就必须得到新浪的官网去注册一个应用的appkey 和appsecret,登录网址：<a href=\"http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！\" target=\"_blank\" rel=\"external\">http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！</a></p>\n<p>这些工作完成以后，我们就要导入友盟的分享的SDK了，话不用说，大家都应该知道有两种方法（手动导入、cocoaPods导入）你只需要选择其中一种就好了。两种方法我都试过了，这里我推荐使用cocoaPods来导入，这样不用自己去配置那些链接库啥的，不容易出错。</p>\n<p>通过cocoaPods导入，首先在你终端中今日你分享项目的目录并且查询友盟分享当前有那些版本:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-f9d0aa966c311156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在这么多版本中你要选择比较新的一个版本，我是选择的4.3这个版本，然后我们就可以在vim中去配置关于友盟的信息：<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9d2c6ee717f20e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后再安装4.3版本的友盟分享SDK，只要出现了complete就表示完成了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-c967fcba2f2cb3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>这个时候，我们再到AppDelegate.m文件中加上两个头文件</p>\n<p> #import “UMSocial.h”  —-&gt;这个头文件是关于友盟的</p>\n<p> #import “UMSocialSinaSSOHandler.h” —–&gt;这个头文件是关于新浪微博的</p>\n<p>下面的appkey对应什么意思都有代码，照着这样写就行了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3911b9688887554c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>我们在处理新浪微博SSO授权以及微信分享完成以后还要跳转回当前app来，所以还要加入下面两端代码</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-211ebe5c6b90c561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在这里，你还得在你项目的info-&gt;URL Types里面添加一个URL Schemes进去</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-0f1fd0ac85eefb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>添加完上面的代码，AppDelegate.m里面的代码算是全部写完了，现在你只需要集成分享功能的视图源码UIViewController.m，把如下代码复制并粘贴到你将弹出一个分享列表的位置后面，例如到响应分享按钮的方法中调用它。并且修改下面的友盟appkey，你要分享的文字、图片，你要分享到的微博平台，例如下面写的是新浪微博、腾讯微博、人人网。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-e392053e01ad3242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>你如果还想要知道你是否分享成功，你还可以调用以下方法</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-06bd9e8712d00d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>到这里，基本上一个完整的新浪微博分享就成功了，但是还有一个最大的坑等着你去填呢，我花了好久才解决的就是这个大坑。因为新浪微博注册的时候你要上传你的app的bundle id，所以你当前项目的bundle id必须跟你申请新浪微博的bundle id一致，不然的话，就会发生分享授权不成功，出现闪退的现象。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b7c1a4b45cacd321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>"},{"title":"cocoaPods升级后遇到的巨坑","date":"2017-07-06T08:03:08.000Z","_content":"  之前我的CocoaPods一直是在0.0.39这个版本中，一直都处于相安无事的状态，后来看到同事将CocoaPods升级到1.1.1正式版本以后，我也跟着装逼，然后就一不小心装逼失败，把CocoaPods升级到最新的bata版本了，最后又搞了半天把版本降为了1.1.1版本。感觉自己棒棒哒，过了年来，完蛋了，出问题了。现在我就完全复现出错的整个流程以及解决办法，帮助有需要的人。\n  <!-- more -->\n  \n#### 一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址\n![image](http://upload-images.jianshu.io/upload_images/1863813-8a52de6c83d0169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\n![image](http://upload-images.jianshu.io/upload_images/1863813-532fb3a37575205a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 三：选中我们需要的那个版本，并复制版本号\n![image](http://upload-images.jianshu.io/upload_images/1863813-6a26413e86a6d89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 四：配置Podfile文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-9ea3e68c4f0f0219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 五：配置后是这样，然后保存Podfile文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-9f48dd88e367465a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？\n![image](http://upload-images.jianshu.io/upload_images/1863813-b839f74aad7d9c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n最后，我们在通过查询资料以后发现。CocoaPods升级后，Podfile文件的内容格式要求发生了变化，必须指出指出所用第三方库的target。没有办法，只能指定对应的target,我查询了一下网上的办法是这样的。\n![image](http://upload-images.jianshu.io/upload_images/1863813-30b1d2c6ad01dedf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n他这样也能实现，但是我觉得还是挺麻烦的，其实我们只需要在配置podfile文件之前创建一个podfile文件以后，他就会自动的生成指定了target的podfile文件。\n![image](http://upload-images.jianshu.io/upload_images/1863813-620b1cb370b3151f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n先创建podfile文件以后，打开pod file文件，你看到的就是这个样子\n![image](http://upload-images.jianshu.io/upload_images/1863813-8e1fe61984957ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个就是需要指定的target的标准格式，系统自己就可以帮你生成，完全不用你去动手敲，最后一步，安装AFNetworking成功\n![image](http://upload-images.jianshu.io/upload_images/1863813-8ca00166c9a13d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n备注：虽然写的繁琐，但是重点是为了把问题讲清楚，希望能给被这个问题带来困惑的人给予帮助，大神勿喷，谢谢！","source":"_posts/cocoaPods升级后遇到的巨坑/cocoaPods升级后遇到的巨坑.md","raw":"---\ntitle: cocoaPods升级后遇到的巨坑\ndate: 2017-07-06 16:03:08\ntags:\n  - cocoaPods\n  - 技术\n  - 终端\n---\n  之前我的CocoaPods一直是在0.0.39这个版本中，一直都处于相安无事的状态，后来看到同事将CocoaPods升级到1.1.1正式版本以后，我也跟着装逼，然后就一不小心装逼失败，把CocoaPods升级到最新的bata版本了，最后又搞了半天把版本降为了1.1.1版本。感觉自己棒棒哒，过了年来，完蛋了，出问题了。现在我就完全复现出错的整个流程以及解决办法，帮助有需要的人。\n  <!-- more -->\n  \n#### 一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址\n![image](http://upload-images.jianshu.io/upload_images/1863813-8a52de6c83d0169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\n![image](http://upload-images.jianshu.io/upload_images/1863813-532fb3a37575205a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 三：选中我们需要的那个版本，并复制版本号\n![image](http://upload-images.jianshu.io/upload_images/1863813-6a26413e86a6d89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 四：配置Podfile文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-9ea3e68c4f0f0219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 五：配置后是这样，然后保存Podfile文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-9f48dd88e367465a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？\n![image](http://upload-images.jianshu.io/upload_images/1863813-b839f74aad7d9c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n最后，我们在通过查询资料以后发现。CocoaPods升级后，Podfile文件的内容格式要求发生了变化，必须指出指出所用第三方库的target。没有办法，只能指定对应的target,我查询了一下网上的办法是这样的。\n![image](http://upload-images.jianshu.io/upload_images/1863813-30b1d2c6ad01dedf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n他这样也能实现，但是我觉得还是挺麻烦的，其实我们只需要在配置podfile文件之前创建一个podfile文件以后，他就会自动的生成指定了target的podfile文件。\n![image](http://upload-images.jianshu.io/upload_images/1863813-620b1cb370b3151f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n先创建podfile文件以后，打开pod file文件，你看到的就是这个样子\n![image](http://upload-images.jianshu.io/upload_images/1863813-8e1fe61984957ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个就是需要指定的target的标准格式，系统自己就可以帮你生成，完全不用你去动手敲，最后一步，安装AFNetworking成功\n![image](http://upload-images.jianshu.io/upload_images/1863813-8ca00166c9a13d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n备注：虽然写的繁琐，但是重点是为了把问题讲清楚，希望能给被这个问题带来困惑的人给予帮助，大神勿喷，谢谢！","slug":"cocoaPods升级后遇到的巨坑/cocoaPods升级后遇到的巨坑","published":1,"updated":"2017-07-06T09:11:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xt00059yho1cgmuoyl","content":"<p>  之前我的CocoaPods一直是在0.0.39这个版本中，一直都处于相安无事的状态，后来看到同事将CocoaPods升级到1.1.1正式版本以后，我也跟着装逼，然后就一不小心装逼失败，把CocoaPods升级到最新的bata版本了，最后又搞了半天把版本降为了1.1.1版本。感觉自己棒棒哒，过了年来，完蛋了，出问题了。现在我就完全复现出错的整个流程以及解决办法，帮助有需要的人。<br>  <a id=\"more\"></a></p>\n<h4 id=\"一：假设我们现在需要安装最新版本AFNetworking-第一步肯定是在终端导入地址\"><a href=\"#一：假设我们现在需要安装最新版本AFNetworking-第一步肯定是在终端导入地址\" class=\"headerlink\" title=\"一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址\"></a>一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8a52de6c83d0169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"二-在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\"><a href=\"#二-在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\" class=\"headerlink\" title=\"二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\"></a>二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-532fb3a37575205a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"三：选中我们需要的那个版本，并复制版本号\"><a href=\"#三：选中我们需要的那个版本，并复制版本号\" class=\"headerlink\" title=\"三：选中我们需要的那个版本，并复制版本号\"></a>三：选中我们需要的那个版本，并复制版本号</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-6a26413e86a6d89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"四：配置Podfile文件\"><a href=\"#四：配置Podfile文件\" class=\"headerlink\" title=\"四：配置Podfile文件\"></a>四：配置Podfile文件</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9ea3e68c4f0f0219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"五：配置后是这样，然后保存Podfile文件\"><a href=\"#五：配置后是这样，然后保存Podfile文件\" class=\"headerlink\" title=\"五：配置后是这样，然后保存Podfile文件\"></a>五：配置后是这样，然后保存Podfile文件</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9f48dd88e367465a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"六-开始安装AFNetworking-这下你会发现报错了，完蛋了，好紧张，怎么办？\"><a href=\"#六-开始安装AFNetworking-这下你会发现报错了，完蛋了，好紧张，怎么办？\" class=\"headerlink\" title=\"六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？\"></a>六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b839f74aad7d9c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>最后，我们在通过查询资料以后发现。CocoaPods升级后，Podfile文件的内容格式要求发生了变化，必须指出指出所用第三方库的target。没有办法，只能指定对应的target,我查询了一下网上的办法是这样的。<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-30b1d2c6ad01dedf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>他这样也能实现，但是我觉得还是挺麻烦的，其实我们只需要在配置podfile文件之前创建一个podfile文件以后，他就会自动的生成指定了target的podfile文件。<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-620b1cb370b3151f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>先创建podfile文件以后，打开pod file文件，你看到的就是这个样子<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8e1fe61984957ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>这个就是需要指定的target的标准格式，系统自己就可以帮你生成，完全不用你去动手敲，最后一步，安装AFNetworking成功<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8ca00166c9a13d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>备注：虽然写的繁琐，但是重点是为了把问题讲清楚，希望能给被这个问题带来困惑的人给予帮助，大神勿喷，谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>  之前我的CocoaPods一直是在0.0.39这个版本中，一直都处于相安无事的状态，后来看到同事将CocoaPods升级到1.1.1正式版本以后，我也跟着装逼，然后就一不小心装逼失败，把CocoaPods升级到最新的bata版本了，最后又搞了半天把版本降为了1.1.1版本。感觉自己棒棒哒，过了年来，完蛋了，出问题了。现在我就完全复现出错的整个流程以及解决办法，帮助有需要的人。<br>","more":"</p>\n<h4 id=\"一：假设我们现在需要安装最新版本AFNetworking-第一步肯定是在终端导入地址\"><a href=\"#一：假设我们现在需要安装最新版本AFNetworking-第一步肯定是在终端导入地址\" class=\"headerlink\" title=\"一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址\"></a>一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8a52de6c83d0169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"二-在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\"><a href=\"#二-在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\" class=\"headerlink\" title=\"二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本\"></a>二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-532fb3a37575205a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"三：选中我们需要的那个版本，并复制版本号\"><a href=\"#三：选中我们需要的那个版本，并复制版本号\" class=\"headerlink\" title=\"三：选中我们需要的那个版本，并复制版本号\"></a>三：选中我们需要的那个版本，并复制版本号</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-6a26413e86a6d89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"四：配置Podfile文件\"><a href=\"#四：配置Podfile文件\" class=\"headerlink\" title=\"四：配置Podfile文件\"></a>四：配置Podfile文件</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9ea3e68c4f0f0219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"五：配置后是这样，然后保存Podfile文件\"><a href=\"#五：配置后是这样，然后保存Podfile文件\" class=\"headerlink\" title=\"五：配置后是这样，然后保存Podfile文件\"></a>五：配置后是这样，然后保存Podfile文件</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9f48dd88e367465a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"六-开始安装AFNetworking-这下你会发现报错了，完蛋了，好紧张，怎么办？\"><a href=\"#六-开始安装AFNetworking-这下你会发现报错了，完蛋了，好紧张，怎么办？\" class=\"headerlink\" title=\"六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？\"></a>六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b839f74aad7d9c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>最后，我们在通过查询资料以后发现。CocoaPods升级后，Podfile文件的内容格式要求发生了变化，必须指出指出所用第三方库的target。没有办法，只能指定对应的target,我查询了一下网上的办法是这样的。<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-30b1d2c6ad01dedf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>他这样也能实现，但是我觉得还是挺麻烦的，其实我们只需要在配置podfile文件之前创建一个podfile文件以后，他就会自动的生成指定了target的podfile文件。<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-620b1cb370b3151f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>先创建podfile文件以后，打开pod file文件，你看到的就是这个样子<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8e1fe61984957ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>这个就是需要指定的target的标准格式，系统自己就可以帮你生成，完全不用你去动手敲，最后一步，安装AFNetworking成功<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8ca00166c9a13d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>备注：虽然写的繁琐，但是重点是为了把问题讲清楚，希望能给被这个问题带来困惑的人给予帮助，大神勿喷，谢谢！</p>"},{"title":"如果通过cocoaPods创建私有库","date":"2017-07-06T07:27:16.000Z","_content":"\n在写代码的时候，有时候封装了一个很好的工具类，系统在以后的项目中也能够被使用，但是每次使用的时候，都需要拷贝代码，感觉很麻烦，所以，我希望能够将这些代码通过cocoaPods来进行托管，这样只需要通过cocoaPods来导入就行了。\n<!-- more -->\n#### 一：咱们第一步需要在github上面创建一个仓库来存储代码\n![image](http://upload-images.jianshu.io/upload_images/1863813-2b1bd2823c867886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\n<img src = 'http://upload-images.jianshu.io/upload_images/1863813-3924f9c806565ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240' align = 'center' />\n\n#### 三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\n![image](http://upload-images.jianshu.io/upload_images/1863813-4e310d4a44fed494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\n![image](http://upload-images.jianshu.io/upload_images/1863813-07e8efb6cf3f0cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 五：将本地代码上传到github上面，上传完以后是这个样子\n![image](http://upload-images.jianshu.io/upload_images/1863813-b9f8d496d3890abd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的\n![image](http://upload-images.jianshu.io/upload_images/1863813-3ce545e532c4f8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-15aeae84bb44547f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 八:新建一个项目，并将其通过cocoaPods导入项目\n![image](http://upload-images.jianshu.io/upload_images/1863813-cf9f0af2bf0d7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了\n![image](http://upload-images.jianshu.io/upload_images/1863813-3e1d402f4f50f140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 十：打开Xcode就可以使用该工具类了\n![image](http://upload-images.jianshu.io/upload_images/1863813-41154c6ca340934d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\n![image](http://upload-images.jianshu.io/upload_images/1863813-3e0379f2dfd52bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/如果通过cocoaPods创建私有库/如果通过cocoaPods创建私有库.md","raw":"---\ntitle: 如果通过cocoaPods创建私有库\ndate: 2017-07-06 15:27:16\ntags:\n  - 私有库 \n  - 技术\n---\n\n在写代码的时候，有时候封装了一个很好的工具类，系统在以后的项目中也能够被使用，但是每次使用的时候，都需要拷贝代码，感觉很麻烦，所以，我希望能够将这些代码通过cocoaPods来进行托管，这样只需要通过cocoaPods来导入就行了。\n<!-- more -->\n#### 一：咱们第一步需要在github上面创建一个仓库来存储代码\n![image](http://upload-images.jianshu.io/upload_images/1863813-2b1bd2823c867886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\n<img src = 'http://upload-images.jianshu.io/upload_images/1863813-3924f9c806565ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240' align = 'center' />\n\n#### 三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\n![image](http://upload-images.jianshu.io/upload_images/1863813-4e310d4a44fed494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\n![image](http://upload-images.jianshu.io/upload_images/1863813-07e8efb6cf3f0cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 五：将本地代码上传到github上面，上传完以后是这个样子\n![image](http://upload-images.jianshu.io/upload_images/1863813-b9f8d496d3890abd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的\n![image](http://upload-images.jianshu.io/upload_images/1863813-3ce545e532c4f8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-15aeae84bb44547f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 八:新建一个项目，并将其通过cocoaPods导入项目\n![image](http://upload-images.jianshu.io/upload_images/1863813-cf9f0af2bf0d7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了\n![image](http://upload-images.jianshu.io/upload_images/1863813-3e1d402f4f50f140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 十：打开Xcode就可以使用该工具类了\n![image](http://upload-images.jianshu.io/upload_images/1863813-41154c6ca340934d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\n![image](http://upload-images.jianshu.io/upload_images/1863813-3e0379f2dfd52bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"如果通过cocoaPods创建私有库/如果通过cocoaPods创建私有库","published":1,"updated":"2017-07-06T09:10:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xu00089yhoy7zwxgfe","content":"<p>在写代码的时候，有时候封装了一个很好的工具类，系统在以后的项目中也能够被使用，但是每次使用的时候，都需要拷贝代码，感觉很麻烦，所以，我希望能够将这些代码通过cocoaPods来进行托管，这样只需要通过cocoaPods来导入就行了。<br><a id=\"more\"></a></p>\n<h4 id=\"一：咱们第一步需要在github上面创建一个仓库来存储代码\"><a href=\"#一：咱们第一步需要在github上面创建一个仓库来存储代码\" class=\"headerlink\" title=\"一：咱们第一步需要在github上面创建一个仓库来存储代码\"></a>一：咱们第一步需要在github上面创建一个仓库来存储代码</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-2b1bd2823c867886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"二-点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\"><a href=\"#二-点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\" class=\"headerlink\" title=\"二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\"></a>二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3924f9c806565ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" align=\"center\"></p>\n<h4 id=\"三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\"><a href=\"#三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\" class=\"headerlink\" title=\"三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\"></a>三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-4e310d4a44fed494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\"><a href=\"#四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\" class=\"headerlink\" title=\"四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\"></a>四：然后在本地创建的文件夹中创建Demo以及工具类文件夹</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-07e8efb6cf3f0cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"五：将本地代码上传到github上面，上传完以后是这个样子\"><a href=\"#五：将本地代码上传到github上面，上传完以后是这个样子\" class=\"headerlink\" title=\"五：将本地代码上传到github上面，上传完以后是这个样子\"></a>五：将本地代码上传到github上面，上传完以后是这个样子</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b9f8d496d3890abd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"六-配置podspec文件-这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime-Text-2这款软件打开的\"><a href=\"#六-配置podspec文件-这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime-Text-2这款软件打开的\" class=\"headerlink\" title=\"六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的\"></a>六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3ce545e532c4f8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\"><a href=\"#七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\" class=\"headerlink\" title=\"七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\"></a>七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-15aeae84bb44547f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"八-新建一个项目，并将其通过cocoaPods导入项目\"><a href=\"#八-新建一个项目，并将其通过cocoaPods导入项目\" class=\"headerlink\" title=\"八:新建一个项目，并将其通过cocoaPods导入项目\"></a>八:新建一个项目，并将其通过cocoaPods导入项目</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-cf9f0af2bf0d7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"九：执行过后，结果就是这样-此时该工具类已经通过cocoaPods导入我们项目中了\"><a href=\"#九：执行过后，结果就是这样-此时该工具类已经通过cocoaPods导入我们项目中了\" class=\"headerlink\" title=\"九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了\"></a>九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3e1d402f4f50f140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"十：打开Xcode就可以使用该工具类了\"><a href=\"#十：打开Xcode就可以使用该工具类了\" class=\"headerlink\" title=\"十：打开Xcode就可以使用该工具类了\"></a>十：打开Xcode就可以使用该工具类了</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-41154c6ca340934d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\"><a href=\"#续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\" class=\"headerlink\" title=\"续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\"></a>续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3e0379f2dfd52bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<p>在写代码的时候，有时候封装了一个很好的工具类，系统在以后的项目中也能够被使用，但是每次使用的时候，都需要拷贝代码，感觉很麻烦，所以，我希望能够将这些代码通过cocoaPods来进行托管，这样只需要通过cocoaPods来导入就行了。<br>","more":"</p>\n<h4 id=\"一：咱们第一步需要在github上面创建一个仓库来存储代码\"><a href=\"#一：咱们第一步需要在github上面创建一个仓库来存储代码\" class=\"headerlink\" title=\"一：咱们第一步需要在github上面创建一个仓库来存储代码\"></a>一：咱们第一步需要在github上面创建一个仓库来存储代码</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-2b1bd2823c867886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"二-点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\"><a href=\"#二-点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\" class=\"headerlink\" title=\"二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹\"></a>二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3924f9c806565ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" align=\"center\"></p>\n<h4 id=\"三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\"><a href=\"#三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\" class=\"headerlink\" title=\"三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库\"></a>三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-4e310d4a44fed494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\"><a href=\"#四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\" class=\"headerlink\" title=\"四：然后在本地创建的文件夹中创建Demo以及工具类文件夹\"></a>四：然后在本地创建的文件夹中创建Demo以及工具类文件夹</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-07e8efb6cf3f0cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"五：将本地代码上传到github上面，上传完以后是这个样子\"><a href=\"#五：将本地代码上传到github上面，上传完以后是这个样子\" class=\"headerlink\" title=\"五：将本地代码上传到github上面，上传完以后是这个样子\"></a>五：将本地代码上传到github上面，上传完以后是这个样子</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b9f8d496d3890abd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"六-配置podspec文件-这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime-Text-2这款软件打开的\"><a href=\"#六-配置podspec文件-这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime-Text-2这款软件打开的\" class=\"headerlink\" title=\"六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的\"></a>六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3ce545e532c4f8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\"><a href=\"#七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\" class=\"headerlink\" title=\"七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件\"></a>七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-15aeae84bb44547f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"八-新建一个项目，并将其通过cocoaPods导入项目\"><a href=\"#八-新建一个项目，并将其通过cocoaPods导入项目\" class=\"headerlink\" title=\"八:新建一个项目，并将其通过cocoaPods导入项目\"></a>八:新建一个项目，并将其通过cocoaPods导入项目</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-cf9f0af2bf0d7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"九：执行过后，结果就是这样-此时该工具类已经通过cocoaPods导入我们项目中了\"><a href=\"#九：执行过后，结果就是这样-此时该工具类已经通过cocoaPods导入我们项目中了\" class=\"headerlink\" title=\"九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了\"></a>九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3e1d402f4f50f140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"十：打开Xcode就可以使用该工具类了\"><a href=\"#十：打开Xcode就可以使用该工具类了\" class=\"headerlink\" title=\"十：打开Xcode就可以使用该工具类了\"></a>十：打开Xcode就可以使用该工具类了</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-41154c6ca340934d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\"><a href=\"#续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\" class=\"headerlink\" title=\"续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式\"></a>续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3e0379f2dfd52bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>"},{"title":"对NSString字符串全部API作解释","date":"2017-07-06T09:13:19.000Z","_content":"\niOS8最新API和一些生僻API，做了红色标注，便于大家查阅\n\n0.定义一个无符号整型 两个字节 范围[0,65535] \n\n\t{typedef unsigned short unichar;}\n\t\n<!-- more -->\n\n1.提前进入以下六个类告诉编译器，六个都是类的名称 \n\n@class NSData,NSArray,NSDictionary,NSCharacterSet,NSURL,NSError,NSLocale;\n\n2.异常处理字符串，控制台出错信息报告 \n\n\t{FOUNDATION_EXPORTNSString *const NSParseErrorException;} \n\n3.宏定义下字符串的最大值 \n\n\t{#define NSMaximumStringLength (INT_MAX-1)} \n4.字符串进行比较\n\noptions typedef NS_OPTIONS(NSUInteger,     NSStringCompareOptions) \n\t{    \n\tNSCaseInsensitiveSearch =1,//\t两个 字符串的比较不区分大小写         \tNSLiteralSearch = 2,//两个字符串的\t比较区分大小写     \tNSBackwardsSearch =4,//从字符串末尾开发查询搜索<br>\tNSAnchoredSearch =8,//搜索有限制范围的字符串 \n\tNSNumericSearch = \t64,//根据字符串里的数字来计算顺序    \tNSDiacriticInsensitiveSearchNS_ENUM_AVAILABLE(10_5,2_0) \t=128,  NSWidthInsensitiveSearch \t\t\tNS_ENUM_AVAILABLE(10_5,2_0) =256,//可以忽略字符串的宽度（长度）\t比较结果 \n\tNSForcedOrderingSearchNS_ENUM_AVAILABLE(10_5,2_0) =512,//\t忽略不区分大小写比较的选项    \t\t\t\t\tNSRegularExpressionSearchNS_ENUM_AVAILABLE(10_7,3_2) \t=1024 //  };\n\t\n5.字符串编码的多种选项 \n\nenum {    \nNSASCIIStringEncoding =1,/* 0..127 only */    NSNEXTSTEPStringEncoding =2,   \nNSJapaneseEUCStringEncoding =3,    \nNSUTF8StringEncoding =4,    \nNSISOLatin1StringEncoding =5,    \nNSSymbolStringEncoding =6,    \nNSNonLossyASCIIStringEncoding =7,    \nNSShiftJISStringEncoding =8, /* kCFStringEncodingDOSJapanese */    \nNSISOLatin2StringEncoding =9,    \nNSUnicodeStringEncoding =10,    \nNSWindowsCP1251StringEncoding = 11,  /* Cyrillic; same as AdobeStandardCyrillic */    \nNSWindowsCP1252StringEncoding =12,  /* WinLatin1 */    NSWindowsCP1253StringEncoding =13,  /* Greek */    NSWindowsCP1254StringEncoding =14,  /* Turkish */    NSWindowsCP1250StringEncoding =15,  /* WinLatin2 */    NSISO2022JPStringEncoding = 21,      /* ISO 2022 Japanese encoding for e-mail */    \nNSMacOSRomanStringEncoding =30,    \nNSUTF16StringEncoding = NSUnicodeStringEncoding,    /* An alias for NSUnicodeStringEncoding */    NSUTF16BigEndianStringEncoding = 0x90000100,        /* NSUTF16StringEncoding encoding with explicit endianness specified */    \nNSUTF16LittleEndianStringEncoding = 0x94000100,      /* NSUTF16StringEncoding encoding with explicit endianness specified */    \nNSUTF32StringEncoding =0x8c000100,                        NSUTF32BigEndianStringEncoding = 0x98000100,        /* NSUTF32StringEncoding encoding with explicit endianness specified */    \nNSUTF32LittleEndianStringEncoding = 0x9c000100      /* NSUTF32StringEncoding encoding with explicit endianness specified */ }; \n\n6.字符串编码 \n\t\t\n\t{typedefNSUInteger NSStringEncoding;}   \n字符串编码转换条件option，下面指定缓冲区转换会用到 \n\n\t{\n\ttypedef NS_OPTIONS(NSUInteger, NSStringEncodingConversionOptions) {    NSStringEncodingConversionAllowLossy =1,    NSStringEncodingConversionExternalRepresentation =2 }; //7.字符转化异常 FOUNDATION_EXPORTNSString *const NSCharacterConversionException; //8. NSString继承NSObject，并遵守以下三个协议 @interface NSString :NSObject//9.只读属性字符串长度length\n    @property (readonly)NSUInteger length;\n    }\n    \n7.选取字符串对应下表的字符\n\n\t{\n\t-(unichar)characterAtIndex:(NSUInteger)index;}\n8.字符串的init初始化方法\n\n\t{-(instancetype)initNS_DESIGNATED_INITIALIZER;}\n9.当一个xib的控件被加载实例化的时候，系统会默认调用这个方法。\n\n\t{- (instancetype)initWithCoder:(NSCoder *)aDecoderNS_DESIGNATED_INITIALIZER;}\n10.NSString的扩展方法\n\n\t{@interface NSString (NSStringExtensionMethods)}\n11.截取字符串的指定段\n\n\t{- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange;}\n12.截取指定位置Index之后字符串\n\n\t{- (NSString *)substringFromIndex:(NSUInteger)from;}\n13.从索引0第一个字符串开始，截取指定长度的字符串\n\n\t{- (NSString *)substringToIndex:(NSUInteger)to;}\n14.截取字符串的指定段，返回值为NSString\n\n\t{- (NSString *)substringWithRange:(NSRange)range;}\n\n15.比较两个字符串\n\n\t{- (NSComparisonResult)compare:(NSString *)string;}\n\n16.比较两个字符串，并加上条件\n\n\t{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;}\n\n17.比较两个字符串，并加上某些条件到指定段\n\n\t{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange;}\n\n18.比较两个字符串，并加上某些条件还有本地化语言环境，在指定段进行比较\n\n\t{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange locale:(id)locale;}\n\n19.不区分大小写比较字符串\n\n\t{- (NSComparisonResult)caseInsensitiveCompare:(NSString *)string;}\n\n20.本地化比较字符串\n\n\t{- (NSComparisonResult)localizedCompare:(NSString *)string;}\n\n21.不区分大小写以及本地化比较字符串\n\n\t{- (NSComparisonResult)localizedCaseInsensitiveCompare:(NSString *)string;}\n\n22.本地化标准字符串比较，返回升序降序相等\n\n\t{- (NSComparisonResult)localizedStandardCompare:(NSString *)stringNS_AVAILABLE(10_6,4_0);}\n23.比较两个字符串是否相等\n\n\t{- (BOOL)isEqualToString:(NSString *)aString;}\n\n24.测试字符串是否以aString开头\n\n\t{- (BOOL)hasPrefix:(NSString *)aString;}\n\n25.测试字符串是否以aString结尾\n\n\t{- (BOOL)hasSuffix:(NSString *)aString;}\n\n26.判断字符串A是否包含aString字符串B，返回值Bool\n\n\t{- (BOOL)containsString:(NSString *)aStringNS_AVAILABLE(10_10,8_0);}\n\n27.这是iOS8的新特性API 判断字符串A是否包含字符串B，不区分大小写，返回Bool\n\n 例：\n\t\n\t{\n\tNSSsring * stringA = @“abcd”;\n\n\tNSSsring * stringB = @“d”;\n\n\tBOOl  test = [stringA localizedCaseInsensitiveContainsString:stringB];\n\n\t输出打印值 YES\n\n\t- (BOOL)localizedCaseInsensitiveContainsString:(NSString *)aString NS_AVAILABLE(10_10, 8_0);}\n\n28.搜索一个字符串是否包含某个字符 rangeOfString前面的参数是要被搜索的字符串，后面的是要搜索的字符\n\n\t{- (NSRange)rangeOfString:(NSString *)aString;}\n\n29.搜索一个字符串是否包含某个字符，并添加筛选条件option\n\n\t{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n\n30.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range\n\n\t{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n\n31.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range,最后还有本地化的设置\n\n\t{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)localeNS_AVAILABLE(10_5,2_0);}\n\n32.指定字符集进行搜索\n\n\t{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet;}\n33.指定字符集进行搜索，并且加上某些限制条件\n\n\t{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask;}\n\n34.指定字符集进行搜索，并且加上某些限制条件，且在指定的位置段进行\n\n\t{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n\n35.用字符串的字符编码指定索引查找位置\n\n\t{- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;}\n\n36.用字符串的字符编码指定区域段查找位置\n\n\t{- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)rangeNS_AVAILABLE(10_5,2_0);}\n\n37.将aString字符串添加到前面字符串A的后面\n\n\t{- (NSString *)stringByAppendingString:(NSString *)aString;}\n\t\n38.将多个字符串添加到前面字符串A的后面\n\n\t{- (NSString *)stringByAppendingFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n39.只读属性 double类型\n\n\t{@property (readonly)double doubleValue;}\n\n40.只读属性 float类型\n\n\t{@property (readonly)float floatValue;}\n\n41.只读属性int类型\n\n\t{@property (readonly)int intValue;}\n\n42.只读属性NSInteger类型\n\n\t{@property (readonly)NSInteger integerValueNS_AVAILABLE(10_5,2_0);}\n43.只读属性long long 类型\n\n\t{@property (readonly)longlong longLongValueNS_AVAILABLE(10_5,2_0);}\n\n44.只读属性BOOL类型\n\n\t{@property (readonly)BOOL boolValueNS_AVAILABLE(10_5,2_0);} \n\n45.将字符串根据传进来的字符串参数separator进行分割，并转化成数组\n\n\t{- (NSArray *)componentsSeparatedByString:(NSString *)separator;}\n\n46.将字符串根据传进来的字符编码separator进行分割，并拆分成数组返回\n\n\t\t{- (NSArray *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separatorNS_AVAILABLE(10_5,2_0);}\n\t\t{- (NSString *)commonPrefixWithString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n47.将字符串的所有字符转化成大写\n\n\t{@property (readonly,copy)NSString *uppercaseString;}\n\n48.将字符串的所有字符转化为小写\n\n\t{@property (readonly,copy)NSString *lowercaseString;}\n\n49.所有单词的首字母转化成大写\n\n\t{@property (readonly,copy)NSString *capitalizedString;}\n\n50.所有字符转化成大写 本地化\n\n\t{- (NSString *)uppercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n\n51.所有字符串转化成小写 本地化\n\n\t{- (NSString *)lowercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n\n52.所有单词首字母转化成大写 本地化\n\n\t{- (NSString *)capitalizedStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n\n53.删除字符串中包含字符集部分的字符 返回字符串\n\n扩展一下，如果想要删除字符串前后的空格或者回车，这样做：\n\n\t{[stringA stringByTrimmingCharactersInSet:  [NSCharacterSetWhitespaceAndNewLineCharacterSet]];\n\n\t- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;}\n\n54.将字符串padString指定索引段添加到前面字符串后面\n\n\t{- (NSString *)stringByPaddingToLength:(NSUInteger)newLength withString:(NSString *)padString startingAtIndex:(NSUInteger)padIndex;}\n\n55.指定段分行去字符串\n\n\t{- (void)getLineStart:(NSUInteger *)startPtr end:(NSUInteger *)lineEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n\n56.返回字符串指定段位置和长度\n\n\t{- (NSRange)lineRangeForRange:(NSRange)range;}\n\n57.给字符串指定段分段取字符串\n\n\t{- (void)getParagraphStart:(NSUInteger *)startPtr end:(NSUInteger *)parEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n\n58.指定段分段的位置和长度\n\n\t{- (NSRange)paragraphRangeForRange:(NSRange)range;}\n\n59.\n\n\t{typedefNS_OPTIONS(NSUInteger, NSStringEnumerationOptions) \n\t{\n\n\t// Pass in one of the \"By\" options:\n\n\tNSStringEnumerationByLines =0,                      // Equivalent to lineRangeForRange:\n\n\tNSStringEnumerationByParagraphs =1,                // Equivalent to paragraphRangeForRange:\n\n\tNSStringEnumerationByComposedCharacterSequences =2, // \tEquivalent to rangeOfComposedCharacterSequencesForRange:\n\n\tNSStringEnumerationByWords =3,\n\n\tNSStringEnumerationBySentences =4,\n\n\t// ...and combine any of the desired additional options:\n\n\tNSStringEnumerationReverse =1UL <<8,\n\n\tNSStringEnumerationSubstringNotRequired =1UL <<9,\n\n\tNSStringEnumerationLocalized =1UL <<10            // \tUser's default locale\n\n\t};}\n\n60.检查是否在指定范围内是否有匹配的字符串\n\n\t{- (void)enumerateSubstringsInRange:(NSRange)range options:(NSStringEnumerationOptions)opts usingBlock:(void (^)(NSString *substring,NSRange substringRange,NSRange enclosingRange, BOOL *stop))blockNS_AVAILABLE(10_6,4_0);}\n\n61.列举枚举字符串所有行\n\n\t{- (void)enumerateLinesUsingBlock:(void (^)(NSString *line,BOOL *stop))block NS_AVAILABLE(10_6,4_0);}\n\n62.字符串\n\n\t{@property (readonly,copy)NSString *description;}\n\n63.返回字符串哈希地址\n\n\t{@property (readonly)NSUInteger hash;}\n\n64.字符串最快编码值\n\n\t{@property (readonly)NSStringEncoding fastestEncoding;} \n\n65.字符串最小编码值\n\n\t{@property (readonly)NSStringEncoding smallestEncoding; } \n\n66.返回指定编码的NSData对象\n\n\t{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)lossy;  // External representation}\n\n67.返回指定编码的NSData对象\n\n\t{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding;                                  // External representation}\n\n68.判断是否可以无损化转码\n\n\t{- (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding;}\n69.char编码转化\n\n\t{- (__strongconstchar *)cStringUsingEncoding:(NSStringEncoding)encodingNS_RETURNS_INNER_POINTER;}\n\n70.C字符串转化是够成功\n\n\t{- (BOOL)getCString:(char *)buffer maxLength:(NSUInteger)maxBufferCount encoding:(NSStringEncoding)encoding;// NO return if conversion not}\n\n71.指定缓存区转换\n\n\t{- (BOOL)getBytes:(void *)buffer maxLength:(NSUInteger)maxBufferCount usedLength:(NSUInteger *)usedBufferCount encoding:(NSStringEncoding)encoding options:(NSStringEncodingConversionOptions)options range:(NSRange)range remainingRange:(NSRangePointer)leftover;}\n\n72.字符串编码时需要用的字节长度\n\n\t{- (NSUInteger)maximumLengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n\n73.字符串编码时需要用到最大字节长度\n\n\t{- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n\n74.unicode范式D标准化\n\n\t{@property (readonly,copy)NSString *decomposedStringWithCanonicalMapping;}\n\n75.unicode范式c标准化\n\n\t{@property (readonly,copy)NSString *precomposedStringWithCanonicalMapping;}\n\n76.unicode范式KD标准化\n\n\t{@property (readonly,copy)NSString *decomposedStringWithCompatibilityMapping;}\n\n77.unicode范式KC标准化\n\n\t{@property (readonly,copy)NSString *precomposedStringWithCompatibilityMapping;}\n\n78.本地化字符串折叠\n\n\t{- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale NS_AVAILABLE(10_5,2_0);}\n\n79.字符串的指定区域段被有条件的替换掉\n\n\t{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:(NSStringCompareOptions)options range:(NSRange)searchRangeNS_AVAILABLE(10_5,2_0);}\n\n80.字符串的特定字符串被替换掉\n\n\t{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n\n81.将字符串的指定区域段字符串被替换掉\n\n\t{- (NSString *)stringByReplacingCharactersInRange:(NSRange)range withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n\n82.将字符串转化为char类型\n\n\t{@property (readonly)__strongconstchar *UTF8StringNS_RETURNS_INNER_POINTER;}\n\n83.默认C字符串编码\n\n\t{+ (NSStringEncoding)defaultCStringEncoding;}\n\n84.可用的字符串编码\n\n\t{+ (constNSStringEncoding *)availableStringEncodings;}\n\n85.编码的名称vheng\n\n\t{+ (NSString *)localizedNameOfStringEncoding:(NSStringEncoding)encoding;}\n\n86.指定缓冲区，编码和字节长度初始化NSString对象\n\n\t{- (instancetype)initWithCharactersNoCopy:(unichar *)characters length:(NSUInteger)length freeWhenDone:(BOOL)freeBuffer;}\n\n87.指定unichar字符，字节长度初始化NSString对象\n\n\t{- (instancetype)initWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n\n88.转化为NSString对象\n\n\t{- (instancetype)initWithUTF8String:(constchar *)nullTerminatedCString;}\n\n89.指定字符串初始化为NSString对象\n\n\t{- (instancetype)initWithString:(NSString *)aString;}\n\n90.格式化多个字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n91.格式化字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n\n92.本地化格式化多个字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale, ...NS_FORMAT_FUNCTION(1,3);}\n\n93.本地化格式化字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n\n94.指定编码转化NSData数据\n\n\t{- (instancetype)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding;}\n\n95.指定编码和字节数初始化NSString对象\n\n\t{- (instancetype)initWithBytes:(constvoid *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding;}\n\n96.指定缓冲区，编码和字节数初始化NSString对象\n\n\t{- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding freeWhenDone:(BOOL)freeBuffer;}\n\n97.初始化空字符串\n\n\t{+ (instancetype)string;}\n\n98.初始化NSString字符串\n\n\t{+ (instancetype)stringWithString:(NSString *)string;}\n\n99.返回指定长度unichar的C字符串\n\n\t{+ (instancetype)stringWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n\n100.转化C字符串为UTF8串\n\n\t{+ (instancetype)stringWithUTF8String:(constchar *)nullTerminatedCString;}\n\n101.初始化NSString对象昂，这种创建方式会自动释放内存，很常用的一种方式\n\n\t{+ (instancetype)stringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n102.初始化NSString自动释放内存，本地化\n\n\t{+ (instancetype)localizedStringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n103.初始化C字符串并且指定编码，在这里需要手动释放内存（init）\n\n\t{- (instancetype)initWithCString:(constchar *)nullTerminatedCString encoding:(NSStringEncoding)encoding;}\n\n104.初始化C字符串并且指定编码，在这里需要自动释放内存\n\n\t{+ (instancetype)stringWithCString:(constchar *)cString encoding:(NSStringEncoding)enc;}\n\n105.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，已经知道编码\n\n\t{- (instancetype)initWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n106.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，已经知道编码\n\n\t{- (instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n107.读取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，已经知道编码\n\n\t{+ (instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n108.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，已经知道编码\n\n\t{+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n109.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，不知道编码\n\n\t{- (instancetype)initWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n110.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，不知道编码\n\n\t{- (instancetype)initWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n111.取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，不知道编码\n\n\t{+ (instancetype)stringWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n112.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，不知道编码\n\n\t{+ (instancetype)stringWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n113.将数据写入URL并且指定编码\n\n\t{- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n114.将数据写入文件并且指定编码\n\n\t{- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;\n\n\t@end\n\n\t@interface NSMutableString :NSString}\n\n115.使用aString替换前面字符串的指定区域字符\n\n\t{- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;}\n\n@end\n\n116.可变字符串的扩展方法\n\n\t{@interface NSMutableString (NSMutableStringExtensionMethods)}\n\n117.插入字符串aString，在指定的loc位置\n\n\t{- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc;}\n\n118.删除指定区域段的字符串\n\n\t{- (void)deleteCharactersInRange:(NSRange)range;}\n\n119.追加字符串aString\n\n\t{- (void)appendString:(NSString *)aString;}\n\n120.追加多个字符串\n\n\t{- (void)appendFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n121.设置新的aString\n\n\t{- (void)setString:(NSString *)aString;}\n\n122.初始化一个容量为capacity大小的字符串，并且需要手动释放内存\n\n\t{- (NSMutableString *)initWithCapacity:(NSUInteger)capacity;}\n\n123.初始化一个容量为capacity大小的字符串，但是不用手动释放内存，这些提前指定的容量，知识用于内存优化，实际大小可以大于设置的容量capacity\n\n\t{+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;}\n\n124.指定限制条件，指定区段中的replacement替换成target\n\n\t{- (NSUInteger)replaceOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:\n\n(NSStringCompareOptions)options range:(NSRange)searchRange;}\n\n@end\n\n125.关于字符串编码检测的扩展\n\n\t{@interface NSString (NSStringEncodingDetection)}\n\n126.对一份data数据进行转换为字符串，有可选option字典，另外还有是否允许有损失，最终转换之后返回一个编码种类。下面是7种不同option字典选项\n\n\t{+ (NSStringEncoding)stringEncodingForData:(NSData *)data\n\n\tencodingOptions:(NSDictionary *)opts\n\n\tconvertedString:(NSString **)string\n\n\tusedLossyConversion:(BOOL *)usedLossyConversion NS_AVAILABLE(10_10, 8_0);\n\n\t\t@end\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionSuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSArray of NSNumbers which contain NSStringEncoding values; if this key is not present in the dictionary, all encodings are considered\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionDisallowedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionUseOnlySuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSNumber boolean value; if this key is not present in the dictionary, the default value is YES\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionAllowLossyKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionFromWindowsKeyNS_AVAILABLE(10_10,8_0);\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLossySubstitutionKeyNS_AVAILABLE(10_10,8_0);\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLikelyLanguageKeyNS_AVAILABLE(10_10,8_0);\n\n\t@interface NSString (NSExtendedStringPropertyListParsing)}\n\n127.将字符串转化为属性列表\n\n\t{例如：NSString * stringA = [NSString stringWithFormat:@“Name =xulin ;\n\n\tage = 23;”];\n\n\tNSLog(@“%@”,[stringA  propertyList]);\n\n\t控制台输出为{\n\n\tName = xulin ;\n\n\tage = 23;\n\n\t}\n\n\t- (id)propertyList;}\n\n128.字符串转化为字典\n\n\t{NSDictionary * dictionary  = [stringA propertyListFromStringFileFormat];\n\n\tNSLog(@“%@”,dictionary);\n\n\t控制台输出为{\n\n\tName = xulin ;\n\n\tage = 23;\n\n\t}\n\n\t- (NSDictionary *)propertyListFromStringsFileFormat\n\n\t@end}\n\n129.下面是一些弃用代码。也就是上面所翻译过的代码。\n\n\t{@interface NSString (NSStringDeprecated)\n\n\t- (constchar *)cStringNS_RETURNS_INNER_POINTERNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (constchar *)lossyCStringNS_RETURNS_INNER_POINTER NS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (NSUInteger)cStringLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCString:(char *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLength range:(NSRange)aRange remainingRange:(NSRangePointer)leftoverRange NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);\n\n\t- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFileNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomicallyNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithCStringNoCopy:(char *)bytes length:(NSUInteger)length freeWhenDone:(BOOL)freeBufferNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCharacters:(unichar *)buffer;\n\n\t@end\n\n\tenum {\n\n\tNSProprietaryStringEncoding =65536  /* Installation-specific encoding */\n\n\t};\n\n\t#if !defined(_OBJC_UNICHAR_H_)\n\n\t#define _OBJC_UNICHAR_H_\n\n\t#endif\n\n\t#define NS_UNICHAR_IS_EIGHT_BIT 0\n\n\t@interface NSSimpleCString :NSString {\n\n\t@package\n\n\tchar *bytes;\n\n\tint numBytes;\n\n\t#if __LP64__\n\n\tint _unused;\n\n\t#endif\n\n\t}\n\n\t@end\n\n\t@interface NSConstantString :NSSimpleCString\n\n\t@end\n\n\t#if __LP64__\n\n\t#else\n\n\texternvoid *_NSConstantStringClassReference;\n\n\t#endif\n\t}\n","source":"_posts/对NSString字符串全部API作解释/对NSString字符串全部API作解释.md","raw":"---\ntitle: 对NSString字符串全部API作解释\ndate: 2017-07-06 17:13:19\ntags:\n  - API\n---\n\niOS8最新API和一些生僻API，做了红色标注，便于大家查阅\n\n0.定义一个无符号整型 两个字节 范围[0,65535] \n\n\t{typedef unsigned short unichar;}\n\t\n<!-- more -->\n\n1.提前进入以下六个类告诉编译器，六个都是类的名称 \n\n@class NSData,NSArray,NSDictionary,NSCharacterSet,NSURL,NSError,NSLocale;\n\n2.异常处理字符串，控制台出错信息报告 \n\n\t{FOUNDATION_EXPORTNSString *const NSParseErrorException;} \n\n3.宏定义下字符串的最大值 \n\n\t{#define NSMaximumStringLength (INT_MAX-1)} \n4.字符串进行比较\n\noptions typedef NS_OPTIONS(NSUInteger,     NSStringCompareOptions) \n\t{    \n\tNSCaseInsensitiveSearch =1,//\t两个 字符串的比较不区分大小写         \tNSLiteralSearch = 2,//两个字符串的\t比较区分大小写     \tNSBackwardsSearch =4,//从字符串末尾开发查询搜索<br>\tNSAnchoredSearch =8,//搜索有限制范围的字符串 \n\tNSNumericSearch = \t64,//根据字符串里的数字来计算顺序    \tNSDiacriticInsensitiveSearchNS_ENUM_AVAILABLE(10_5,2_0) \t=128,  NSWidthInsensitiveSearch \t\t\tNS_ENUM_AVAILABLE(10_5,2_0) =256,//可以忽略字符串的宽度（长度）\t比较结果 \n\tNSForcedOrderingSearchNS_ENUM_AVAILABLE(10_5,2_0) =512,//\t忽略不区分大小写比较的选项    \t\t\t\t\tNSRegularExpressionSearchNS_ENUM_AVAILABLE(10_7,3_2) \t=1024 //  };\n\t\n5.字符串编码的多种选项 \n\nenum {    \nNSASCIIStringEncoding =1,/* 0..127 only */    NSNEXTSTEPStringEncoding =2,   \nNSJapaneseEUCStringEncoding =3,    \nNSUTF8StringEncoding =4,    \nNSISOLatin1StringEncoding =5,    \nNSSymbolStringEncoding =6,    \nNSNonLossyASCIIStringEncoding =7,    \nNSShiftJISStringEncoding =8, /* kCFStringEncodingDOSJapanese */    \nNSISOLatin2StringEncoding =9,    \nNSUnicodeStringEncoding =10,    \nNSWindowsCP1251StringEncoding = 11,  /* Cyrillic; same as AdobeStandardCyrillic */    \nNSWindowsCP1252StringEncoding =12,  /* WinLatin1 */    NSWindowsCP1253StringEncoding =13,  /* Greek */    NSWindowsCP1254StringEncoding =14,  /* Turkish */    NSWindowsCP1250StringEncoding =15,  /* WinLatin2 */    NSISO2022JPStringEncoding = 21,      /* ISO 2022 Japanese encoding for e-mail */    \nNSMacOSRomanStringEncoding =30,    \nNSUTF16StringEncoding = NSUnicodeStringEncoding,    /* An alias for NSUnicodeStringEncoding */    NSUTF16BigEndianStringEncoding = 0x90000100,        /* NSUTF16StringEncoding encoding with explicit endianness specified */    \nNSUTF16LittleEndianStringEncoding = 0x94000100,      /* NSUTF16StringEncoding encoding with explicit endianness specified */    \nNSUTF32StringEncoding =0x8c000100,                        NSUTF32BigEndianStringEncoding = 0x98000100,        /* NSUTF32StringEncoding encoding with explicit endianness specified */    \nNSUTF32LittleEndianStringEncoding = 0x9c000100      /* NSUTF32StringEncoding encoding with explicit endianness specified */ }; \n\n6.字符串编码 \n\t\t\n\t{typedefNSUInteger NSStringEncoding;}   \n字符串编码转换条件option，下面指定缓冲区转换会用到 \n\n\t{\n\ttypedef NS_OPTIONS(NSUInteger, NSStringEncodingConversionOptions) {    NSStringEncodingConversionAllowLossy =1,    NSStringEncodingConversionExternalRepresentation =2 }; //7.字符转化异常 FOUNDATION_EXPORTNSString *const NSCharacterConversionException; //8. NSString继承NSObject，并遵守以下三个协议 @interface NSString :NSObject//9.只读属性字符串长度length\n    @property (readonly)NSUInteger length;\n    }\n    \n7.选取字符串对应下表的字符\n\n\t{\n\t-(unichar)characterAtIndex:(NSUInteger)index;}\n8.字符串的init初始化方法\n\n\t{-(instancetype)initNS_DESIGNATED_INITIALIZER;}\n9.当一个xib的控件被加载实例化的时候，系统会默认调用这个方法。\n\n\t{- (instancetype)initWithCoder:(NSCoder *)aDecoderNS_DESIGNATED_INITIALIZER;}\n10.NSString的扩展方法\n\n\t{@interface NSString (NSStringExtensionMethods)}\n11.截取字符串的指定段\n\n\t{- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange;}\n12.截取指定位置Index之后字符串\n\n\t{- (NSString *)substringFromIndex:(NSUInteger)from;}\n13.从索引0第一个字符串开始，截取指定长度的字符串\n\n\t{- (NSString *)substringToIndex:(NSUInteger)to;}\n14.截取字符串的指定段，返回值为NSString\n\n\t{- (NSString *)substringWithRange:(NSRange)range;}\n\n15.比较两个字符串\n\n\t{- (NSComparisonResult)compare:(NSString *)string;}\n\n16.比较两个字符串，并加上条件\n\n\t{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;}\n\n17.比较两个字符串，并加上某些条件到指定段\n\n\t{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange;}\n\n18.比较两个字符串，并加上某些条件还有本地化语言环境，在指定段进行比较\n\n\t{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange locale:(id)locale;}\n\n19.不区分大小写比较字符串\n\n\t{- (NSComparisonResult)caseInsensitiveCompare:(NSString *)string;}\n\n20.本地化比较字符串\n\n\t{- (NSComparisonResult)localizedCompare:(NSString *)string;}\n\n21.不区分大小写以及本地化比较字符串\n\n\t{- (NSComparisonResult)localizedCaseInsensitiveCompare:(NSString *)string;}\n\n22.本地化标准字符串比较，返回升序降序相等\n\n\t{- (NSComparisonResult)localizedStandardCompare:(NSString *)stringNS_AVAILABLE(10_6,4_0);}\n23.比较两个字符串是否相等\n\n\t{- (BOOL)isEqualToString:(NSString *)aString;}\n\n24.测试字符串是否以aString开头\n\n\t{- (BOOL)hasPrefix:(NSString *)aString;}\n\n25.测试字符串是否以aString结尾\n\n\t{- (BOOL)hasSuffix:(NSString *)aString;}\n\n26.判断字符串A是否包含aString字符串B，返回值Bool\n\n\t{- (BOOL)containsString:(NSString *)aStringNS_AVAILABLE(10_10,8_0);}\n\n27.这是iOS8的新特性API 判断字符串A是否包含字符串B，不区分大小写，返回Bool\n\n 例：\n\t\n\t{\n\tNSSsring * stringA = @“abcd”;\n\n\tNSSsring * stringB = @“d”;\n\n\tBOOl  test = [stringA localizedCaseInsensitiveContainsString:stringB];\n\n\t输出打印值 YES\n\n\t- (BOOL)localizedCaseInsensitiveContainsString:(NSString *)aString NS_AVAILABLE(10_10, 8_0);}\n\n28.搜索一个字符串是否包含某个字符 rangeOfString前面的参数是要被搜索的字符串，后面的是要搜索的字符\n\n\t{- (NSRange)rangeOfString:(NSString *)aString;}\n\n29.搜索一个字符串是否包含某个字符，并添加筛选条件option\n\n\t{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n\n30.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range\n\n\t{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n\n31.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range,最后还有本地化的设置\n\n\t{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)localeNS_AVAILABLE(10_5,2_0);}\n\n32.指定字符集进行搜索\n\n\t{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet;}\n33.指定字符集进行搜索，并且加上某些限制条件\n\n\t{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask;}\n\n34.指定字符集进行搜索，并且加上某些限制条件，且在指定的位置段进行\n\n\t{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n\n35.用字符串的字符编码指定索引查找位置\n\n\t{- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;}\n\n36.用字符串的字符编码指定区域段查找位置\n\n\t{- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)rangeNS_AVAILABLE(10_5,2_0);}\n\n37.将aString字符串添加到前面字符串A的后面\n\n\t{- (NSString *)stringByAppendingString:(NSString *)aString;}\n\t\n38.将多个字符串添加到前面字符串A的后面\n\n\t{- (NSString *)stringByAppendingFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n39.只读属性 double类型\n\n\t{@property (readonly)double doubleValue;}\n\n40.只读属性 float类型\n\n\t{@property (readonly)float floatValue;}\n\n41.只读属性int类型\n\n\t{@property (readonly)int intValue;}\n\n42.只读属性NSInteger类型\n\n\t{@property (readonly)NSInteger integerValueNS_AVAILABLE(10_5,2_0);}\n43.只读属性long long 类型\n\n\t{@property (readonly)longlong longLongValueNS_AVAILABLE(10_5,2_0);}\n\n44.只读属性BOOL类型\n\n\t{@property (readonly)BOOL boolValueNS_AVAILABLE(10_5,2_0);} \n\n45.将字符串根据传进来的字符串参数separator进行分割，并转化成数组\n\n\t{- (NSArray *)componentsSeparatedByString:(NSString *)separator;}\n\n46.将字符串根据传进来的字符编码separator进行分割，并拆分成数组返回\n\n\t\t{- (NSArray *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separatorNS_AVAILABLE(10_5,2_0);}\n\t\t{- (NSString *)commonPrefixWithString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n47.将字符串的所有字符转化成大写\n\n\t{@property (readonly,copy)NSString *uppercaseString;}\n\n48.将字符串的所有字符转化为小写\n\n\t{@property (readonly,copy)NSString *lowercaseString;}\n\n49.所有单词的首字母转化成大写\n\n\t{@property (readonly,copy)NSString *capitalizedString;}\n\n50.所有字符转化成大写 本地化\n\n\t{- (NSString *)uppercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n\n51.所有字符串转化成小写 本地化\n\n\t{- (NSString *)lowercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n\n52.所有单词首字母转化成大写 本地化\n\n\t{- (NSString *)capitalizedStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n\n53.删除字符串中包含字符集部分的字符 返回字符串\n\n扩展一下，如果想要删除字符串前后的空格或者回车，这样做：\n\n\t{[stringA stringByTrimmingCharactersInSet:  [NSCharacterSetWhitespaceAndNewLineCharacterSet]];\n\n\t- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;}\n\n54.将字符串padString指定索引段添加到前面字符串后面\n\n\t{- (NSString *)stringByPaddingToLength:(NSUInteger)newLength withString:(NSString *)padString startingAtIndex:(NSUInteger)padIndex;}\n\n55.指定段分行去字符串\n\n\t{- (void)getLineStart:(NSUInteger *)startPtr end:(NSUInteger *)lineEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n\n56.返回字符串指定段位置和长度\n\n\t{- (NSRange)lineRangeForRange:(NSRange)range;}\n\n57.给字符串指定段分段取字符串\n\n\t{- (void)getParagraphStart:(NSUInteger *)startPtr end:(NSUInteger *)parEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n\n58.指定段分段的位置和长度\n\n\t{- (NSRange)paragraphRangeForRange:(NSRange)range;}\n\n59.\n\n\t{typedefNS_OPTIONS(NSUInteger, NSStringEnumerationOptions) \n\t{\n\n\t// Pass in one of the \"By\" options:\n\n\tNSStringEnumerationByLines =0,                      // Equivalent to lineRangeForRange:\n\n\tNSStringEnumerationByParagraphs =1,                // Equivalent to paragraphRangeForRange:\n\n\tNSStringEnumerationByComposedCharacterSequences =2, // \tEquivalent to rangeOfComposedCharacterSequencesForRange:\n\n\tNSStringEnumerationByWords =3,\n\n\tNSStringEnumerationBySentences =4,\n\n\t// ...and combine any of the desired additional options:\n\n\tNSStringEnumerationReverse =1UL <<8,\n\n\tNSStringEnumerationSubstringNotRequired =1UL <<9,\n\n\tNSStringEnumerationLocalized =1UL <<10            // \tUser's default locale\n\n\t};}\n\n60.检查是否在指定范围内是否有匹配的字符串\n\n\t{- (void)enumerateSubstringsInRange:(NSRange)range options:(NSStringEnumerationOptions)opts usingBlock:(void (^)(NSString *substring,NSRange substringRange,NSRange enclosingRange, BOOL *stop))blockNS_AVAILABLE(10_6,4_0);}\n\n61.列举枚举字符串所有行\n\n\t{- (void)enumerateLinesUsingBlock:(void (^)(NSString *line,BOOL *stop))block NS_AVAILABLE(10_6,4_0);}\n\n62.字符串\n\n\t{@property (readonly,copy)NSString *description;}\n\n63.返回字符串哈希地址\n\n\t{@property (readonly)NSUInteger hash;}\n\n64.字符串最快编码值\n\n\t{@property (readonly)NSStringEncoding fastestEncoding;} \n\n65.字符串最小编码值\n\n\t{@property (readonly)NSStringEncoding smallestEncoding; } \n\n66.返回指定编码的NSData对象\n\n\t{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)lossy;  // External representation}\n\n67.返回指定编码的NSData对象\n\n\t{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding;                                  // External representation}\n\n68.判断是否可以无损化转码\n\n\t{- (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding;}\n69.char编码转化\n\n\t{- (__strongconstchar *)cStringUsingEncoding:(NSStringEncoding)encodingNS_RETURNS_INNER_POINTER;}\n\n70.C字符串转化是够成功\n\n\t{- (BOOL)getCString:(char *)buffer maxLength:(NSUInteger)maxBufferCount encoding:(NSStringEncoding)encoding;// NO return if conversion not}\n\n71.指定缓存区转换\n\n\t{- (BOOL)getBytes:(void *)buffer maxLength:(NSUInteger)maxBufferCount usedLength:(NSUInteger *)usedBufferCount encoding:(NSStringEncoding)encoding options:(NSStringEncodingConversionOptions)options range:(NSRange)range remainingRange:(NSRangePointer)leftover;}\n\n72.字符串编码时需要用的字节长度\n\n\t{- (NSUInteger)maximumLengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n\n73.字符串编码时需要用到最大字节长度\n\n\t{- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n\n74.unicode范式D标准化\n\n\t{@property (readonly,copy)NSString *decomposedStringWithCanonicalMapping;}\n\n75.unicode范式c标准化\n\n\t{@property (readonly,copy)NSString *precomposedStringWithCanonicalMapping;}\n\n76.unicode范式KD标准化\n\n\t{@property (readonly,copy)NSString *decomposedStringWithCompatibilityMapping;}\n\n77.unicode范式KC标准化\n\n\t{@property (readonly,copy)NSString *precomposedStringWithCompatibilityMapping;}\n\n78.本地化字符串折叠\n\n\t{- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale NS_AVAILABLE(10_5,2_0);}\n\n79.字符串的指定区域段被有条件的替换掉\n\n\t{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:(NSStringCompareOptions)options range:(NSRange)searchRangeNS_AVAILABLE(10_5,2_0);}\n\n80.字符串的特定字符串被替换掉\n\n\t{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n\n81.将字符串的指定区域段字符串被替换掉\n\n\t{- (NSString *)stringByReplacingCharactersInRange:(NSRange)range withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n\n82.将字符串转化为char类型\n\n\t{@property (readonly)__strongconstchar *UTF8StringNS_RETURNS_INNER_POINTER;}\n\n83.默认C字符串编码\n\n\t{+ (NSStringEncoding)defaultCStringEncoding;}\n\n84.可用的字符串编码\n\n\t{+ (constNSStringEncoding *)availableStringEncodings;}\n\n85.编码的名称vheng\n\n\t{+ (NSString *)localizedNameOfStringEncoding:(NSStringEncoding)encoding;}\n\n86.指定缓冲区，编码和字节长度初始化NSString对象\n\n\t{- (instancetype)initWithCharactersNoCopy:(unichar *)characters length:(NSUInteger)length freeWhenDone:(BOOL)freeBuffer;}\n\n87.指定unichar字符，字节长度初始化NSString对象\n\n\t{- (instancetype)initWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n\n88.转化为NSString对象\n\n\t{- (instancetype)initWithUTF8String:(constchar *)nullTerminatedCString;}\n\n89.指定字符串初始化为NSString对象\n\n\t{- (instancetype)initWithString:(NSString *)aString;}\n\n90.格式化多个字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n91.格式化字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n\n92.本地化格式化多个字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale, ...NS_FORMAT_FUNCTION(1,3);}\n\n93.本地化格式化字符串初始化NSString对象\n\n\t{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n\n94.指定编码转化NSData数据\n\n\t{- (instancetype)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding;}\n\n95.指定编码和字节数初始化NSString对象\n\n\t{- (instancetype)initWithBytes:(constvoid *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding;}\n\n96.指定缓冲区，编码和字节数初始化NSString对象\n\n\t{- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding freeWhenDone:(BOOL)freeBuffer;}\n\n97.初始化空字符串\n\n\t{+ (instancetype)string;}\n\n98.初始化NSString字符串\n\n\t{+ (instancetype)stringWithString:(NSString *)string;}\n\n99.返回指定长度unichar的C字符串\n\n\t{+ (instancetype)stringWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n\n100.转化C字符串为UTF8串\n\n\t{+ (instancetype)stringWithUTF8String:(constchar *)nullTerminatedCString;}\n\n101.初始化NSString对象昂，这种创建方式会自动释放内存，很常用的一种方式\n\n\t{+ (instancetype)stringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n102.初始化NSString自动释放内存，本地化\n\n\t{+ (instancetype)localizedStringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n103.初始化C字符串并且指定编码，在这里需要手动释放内存（init）\n\n\t{- (instancetype)initWithCString:(constchar *)nullTerminatedCString encoding:(NSStringEncoding)encoding;}\n\n104.初始化C字符串并且指定编码，在这里需要自动释放内存\n\n\t{+ (instancetype)stringWithCString:(constchar *)cString encoding:(NSStringEncoding)enc;}\n\n105.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，已经知道编码\n\n\t{- (instancetype)initWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n106.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，已经知道编码\n\n\t{- (instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n107.读取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，已经知道编码\n\n\t{+ (instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n108.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，已经知道编码\n\n\t{+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n109.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，不知道编码\n\n\t{- (instancetype)initWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n110.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，不知道编码\n\n\t{- (instancetype)initWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n111.取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，不知道编码\n\n\t{+ (instancetype)stringWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n112.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，不知道编码\n\n\t{+ (instancetype)stringWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n\n113.将数据写入URL并且指定编码\n\n\t{- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;}\n\n114.将数据写入文件并且指定编码\n\n\t{- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;\n\n\t@end\n\n\t@interface NSMutableString :NSString}\n\n115.使用aString替换前面字符串的指定区域字符\n\n\t{- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;}\n\n@end\n\n116.可变字符串的扩展方法\n\n\t{@interface NSMutableString (NSMutableStringExtensionMethods)}\n\n117.插入字符串aString，在指定的loc位置\n\n\t{- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc;}\n\n118.删除指定区域段的字符串\n\n\t{- (void)deleteCharactersInRange:(NSRange)range;}\n\n119.追加字符串aString\n\n\t{- (void)appendString:(NSString *)aString;}\n\n120.追加多个字符串\n\n\t{- (void)appendFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n\n121.设置新的aString\n\n\t{- (void)setString:(NSString *)aString;}\n\n122.初始化一个容量为capacity大小的字符串，并且需要手动释放内存\n\n\t{- (NSMutableString *)initWithCapacity:(NSUInteger)capacity;}\n\n123.初始化一个容量为capacity大小的字符串，但是不用手动释放内存，这些提前指定的容量，知识用于内存优化，实际大小可以大于设置的容量capacity\n\n\t{+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;}\n\n124.指定限制条件，指定区段中的replacement替换成target\n\n\t{- (NSUInteger)replaceOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:\n\n(NSStringCompareOptions)options range:(NSRange)searchRange;}\n\n@end\n\n125.关于字符串编码检测的扩展\n\n\t{@interface NSString (NSStringEncodingDetection)}\n\n126.对一份data数据进行转换为字符串，有可选option字典，另外还有是否允许有损失，最终转换之后返回一个编码种类。下面是7种不同option字典选项\n\n\t{+ (NSStringEncoding)stringEncodingForData:(NSData *)data\n\n\tencodingOptions:(NSDictionary *)opts\n\n\tconvertedString:(NSString **)string\n\n\tusedLossyConversion:(BOOL *)usedLossyConversion NS_AVAILABLE(10_10, 8_0);\n\n\t\t@end\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionSuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSArray of NSNumbers which contain NSStringEncoding values; if this key is not present in the dictionary, all encodings are considered\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionDisallowedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionUseOnlySuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSNumber boolean value; if this key is not present in the dictionary, the default value is YES\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionAllowLossyKeyNS_AVAILABLE(10_10,8_0);\n\n\t// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionFromWindowsKeyNS_AVAILABLE(10_10,8_0);\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLossySubstitutionKeyNS_AVAILABLE(10_10,8_0);\n\n\tFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLikelyLanguageKeyNS_AVAILABLE(10_10,8_0);\n\n\t@interface NSString (NSExtendedStringPropertyListParsing)}\n\n127.将字符串转化为属性列表\n\n\t{例如：NSString * stringA = [NSString stringWithFormat:@“Name =xulin ;\n\n\tage = 23;”];\n\n\tNSLog(@“%@”,[stringA  propertyList]);\n\n\t控制台输出为{\n\n\tName = xulin ;\n\n\tage = 23;\n\n\t}\n\n\t- (id)propertyList;}\n\n128.字符串转化为字典\n\n\t{NSDictionary * dictionary  = [stringA propertyListFromStringFileFormat];\n\n\tNSLog(@“%@”,dictionary);\n\n\t控制台输出为{\n\n\tName = xulin ;\n\n\tage = 23;\n\n\t}\n\n\t- (NSDictionary *)propertyListFromStringsFileFormat\n\n\t@end}\n\n129.下面是一些弃用代码。也就是上面所翻译过的代码。\n\n\t{@interface NSString (NSStringDeprecated)\n\n\t- (constchar *)cStringNS_RETURNS_INNER_POINTERNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (constchar *)lossyCStringNS_RETURNS_INNER_POINTER NS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (NSUInteger)cStringLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCString:(char *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLength range:(NSRange)aRange remainingRange:(NSRangePointer)leftoverRange NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);\n\n\t- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFileNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomicallyNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithCStringNoCopy:(char *)bytes length:(NSUInteger)length freeWhenDone:(BOOL)freeBufferNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (id)initWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t+ (id)stringWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n\t- (void)getCharacters:(unichar *)buffer;\n\n\t@end\n\n\tenum {\n\n\tNSProprietaryStringEncoding =65536  /* Installation-specific encoding */\n\n\t};\n\n\t#if !defined(_OBJC_UNICHAR_H_)\n\n\t#define _OBJC_UNICHAR_H_\n\n\t#endif\n\n\t#define NS_UNICHAR_IS_EIGHT_BIT 0\n\n\t@interface NSSimpleCString :NSString {\n\n\t@package\n\n\tchar *bytes;\n\n\tint numBytes;\n\n\t#if __LP64__\n\n\tint _unused;\n\n\t#endif\n\n\t}\n\n\t@end\n\n\t@interface NSConstantString :NSSimpleCString\n\n\t@end\n\n\t#if __LP64__\n\n\t#else\n\n\texternvoid *_NSConstantStringClassReference;\n\n\t#endif\n\t}\n","slug":"对NSString字符串全部API作解释/对NSString字符串全部API作解释","published":1,"updated":"2017-07-06T10:42:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xu00099yho2kqknw1g","content":"<p>iOS8最新API和一些生僻API，做了红色标注，便于大家查阅</p>\n<p>0.定义一个无符号整型 两个字节 范围[0,65535] </p>\n<pre><code>{typedef unsigned short unichar;}\n</code></pre><a id=\"more\"></a>\n<p>1.提前进入以下六个类告诉编译器，六个都是类的名称 </p>\n<p>@class NSData,NSArray,NSDictionary,NSCharacterSet,NSURL,NSError,NSLocale;</p>\n<p>2.异常处理字符串，控制台出错信息报告 </p>\n<pre><code>{FOUNDATION_EXPORTNSString *const NSParseErrorException;} \n</code></pre><p>3.宏定义下字符串的最大值 </p>\n<pre><code>{#define NSMaximumStringLength (INT_MAX-1)} \n</code></pre><p>4.字符串进行比较</p>\n<p>options typedef NS_OPTIONS(NSUInteger,     NSStringCompareOptions)<br>    {<br>    NSCaseInsensitiveSearch =1,//    两个 字符串的比较不区分大小写             NSLiteralSearch = 2,//两个字符串的    比较区分大小写         NSBackwardsSearch =4,//从字符串末尾开发查询搜索<br>    NSAnchoredSearch =8,//搜索有限制范围的字符串<br>    NSNumericSearch =     64,//根据字符串里的数字来计算顺序        NSDiacriticInsensitiveSearchNS_ENUM_AVAILABLE(10_5,2_0)     =128,  NSWidthInsensitiveSearch             NS_ENUM_AVAILABLE(10_5,2_0) =256,//可以忽略字符串的宽度（长度）    比较结果<br>    NSForcedOrderingSearchNS_ENUM_AVAILABLE(10_5,2_0) =512,//    忽略不区分大小写比较的选项                        NSRegularExpressionSearchNS_ENUM_AVAILABLE(10_7,3_2)     =1024 //  };</p>\n<p>5.字符串编码的多种选项 </p>\n<p>enum {<br>NSASCIIStringEncoding =1,/<em> 0..127 only </em>/    NSNEXTSTEPStringEncoding =2,<br>NSJapaneseEUCStringEncoding =3,<br>NSUTF8StringEncoding =4,<br>NSISOLatin1StringEncoding =5,<br>NSSymbolStringEncoding =6,<br>NSNonLossyASCIIStringEncoding =7,<br>NSShiftJISStringEncoding =8, /<em> kCFStringEncodingDOSJapanese </em>/<br>NSISOLatin2StringEncoding =9,<br>NSUnicodeStringEncoding =10,<br>NSWindowsCP1251StringEncoding = 11,  /<em> Cyrillic; same as AdobeStandardCyrillic </em>/<br>NSWindowsCP1252StringEncoding =12,  /<em> WinLatin1 </em>/    NSWindowsCP1253StringEncoding =13,  /<em> Greek </em>/    NSWindowsCP1254StringEncoding =14,  /<em> Turkish </em>/    NSWindowsCP1250StringEncoding =15,  /<em> WinLatin2 </em>/    NSISO2022JPStringEncoding = 21,      /<em> ISO 2022 Japanese encoding for e-mail </em>/<br>NSMacOSRomanStringEncoding =30,<br>NSUTF16StringEncoding = NSUnicodeStringEncoding,    /<em> An alias for NSUnicodeStringEncoding </em>/    NSUTF16BigEndianStringEncoding = 0x90000100,        /<em> NSUTF16StringEncoding encoding with explicit endianness specified </em>/<br>NSUTF16LittleEndianStringEncoding = 0x94000100,      /<em> NSUTF16StringEncoding encoding with explicit endianness specified </em>/<br>NSUTF32StringEncoding =0x8c000100,                        NSUTF32BigEndianStringEncoding = 0x98000100,        /<em> NSUTF32StringEncoding encoding with explicit endianness specified </em>/<br>NSUTF32LittleEndianStringEncoding = 0x9c000100      /<em> NSUTF32StringEncoding encoding with explicit endianness specified </em>/ }; </p>\n<p>6.字符串编码 </p>\n<pre><code>{typedefNSUInteger NSStringEncoding;}   \n</code></pre><p>字符串编码转换条件option，下面指定缓冲区转换会用到 </p>\n<pre><code>{\ntypedef NS_OPTIONS(NSUInteger, NSStringEncodingConversionOptions) {    NSStringEncodingConversionAllowLossy =1,    NSStringEncodingConversionExternalRepresentation =2 }; //7.字符转化异常 FOUNDATION_EXPORTNSString *const NSCharacterConversionException; //8. NSString继承NSObject，并遵守以下三个协议 @interface NSString :NSObject//9.只读属性字符串长度length\n@property (readonly)NSUInteger length;\n}\n</code></pre><p>7.选取字符串对应下表的字符</p>\n<pre><code>{\n-(unichar)characterAtIndex:(NSUInteger)index;}\n</code></pre><p>8.字符串的init初始化方法</p>\n<pre><code>{-(instancetype)initNS_DESIGNATED_INITIALIZER;}\n</code></pre><p>9.当一个xib的控件被加载实例化的时候，系统会默认调用这个方法。</p>\n<pre><code>{- (instancetype)initWithCoder:(NSCoder *)aDecoderNS_DESIGNATED_INITIALIZER;}\n</code></pre><p>10.NSString的扩展方法</p>\n<pre><code>{@interface NSString (NSStringExtensionMethods)}\n</code></pre><p>11.截取字符串的指定段</p>\n<pre><code>{- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange;}\n</code></pre><p>12.截取指定位置Index之后字符串</p>\n<pre><code>{- (NSString *)substringFromIndex:(NSUInteger)from;}\n</code></pre><p>13.从索引0第一个字符串开始，截取指定长度的字符串</p>\n<pre><code>{- (NSString *)substringToIndex:(NSUInteger)to;}\n</code></pre><p>14.截取字符串的指定段，返回值为NSString</p>\n<pre><code>{- (NSString *)substringWithRange:(NSRange)range;}\n</code></pre><p>15.比较两个字符串</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string;}\n</code></pre><p>16.比较两个字符串，并加上条件</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;}\n</code></pre><p>17.比较两个字符串，并加上某些条件到指定段</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange;}\n</code></pre><p>18.比较两个字符串，并加上某些条件还有本地化语言环境，在指定段进行比较</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange locale:(id)locale;}\n</code></pre><p>19.不区分大小写比较字符串</p>\n<pre><code>{- (NSComparisonResult)caseInsensitiveCompare:(NSString *)string;}\n</code></pre><p>20.本地化比较字符串</p>\n<pre><code>{- (NSComparisonResult)localizedCompare:(NSString *)string;}\n</code></pre><p>21.不区分大小写以及本地化比较字符串</p>\n<pre><code>{- (NSComparisonResult)localizedCaseInsensitiveCompare:(NSString *)string;}\n</code></pre><p>22.本地化标准字符串比较，返回升序降序相等</p>\n<pre><code>{- (NSComparisonResult)localizedStandardCompare:(NSString *)stringNS_AVAILABLE(10_6,4_0);}\n</code></pre><p>23.比较两个字符串是否相等</p>\n<pre><code>{- (BOOL)isEqualToString:(NSString *)aString;}\n</code></pre><p>24.测试字符串是否以aString开头</p>\n<pre><code>{- (BOOL)hasPrefix:(NSString *)aString;}\n</code></pre><p>25.测试字符串是否以aString结尾</p>\n<pre><code>{- (BOOL)hasSuffix:(NSString *)aString;}\n</code></pre><p>26.判断字符串A是否包含aString字符串B，返回值Bool</p>\n<pre><code>{- (BOOL)containsString:(NSString *)aStringNS_AVAILABLE(10_10,8_0);}\n</code></pre><p>27.这是iOS8的新特性API 判断字符串A是否包含字符串B，不区分大小写，返回Bool</p>\n<p> 例：</p>\n<pre><code>{\nNSSsring * stringA = @“abcd”;\n\nNSSsring * stringB = @“d”;\n\nBOOl  test = [stringA localizedCaseInsensitiveContainsString:stringB];\n\n输出打印值 YES\n\n- (BOOL)localizedCaseInsensitiveContainsString:(NSString *)aString NS_AVAILABLE(10_10, 8_0);}\n</code></pre><p>28.搜索一个字符串是否包含某个字符 rangeOfString前面的参数是要被搜索的字符串，后面的是要搜索的字符</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString;}\n</code></pre><p>29.搜索一个字符串是否包含某个字符，并添加筛选条件option</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n</code></pre><p>30.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n</code></pre><p>31.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range,最后还有本地化的设置</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)localeNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>32.指定字符集进行搜索</p>\n<pre><code>{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet;}\n</code></pre><p>33.指定字符集进行搜索，并且加上某些限制条件</p>\n<pre><code>{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask;}\n</code></pre><p>34.指定字符集进行搜索，并且加上某些限制条件，且在指定的位置段进行</p>\n<pre><code>{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n</code></pre><p>35.用字符串的字符编码指定索引查找位置</p>\n<pre><code>{- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;}\n</code></pre><p>36.用字符串的字符编码指定区域段查找位置</p>\n<pre><code>{- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)rangeNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>37.将aString字符串添加到前面字符串A的后面</p>\n<pre><code>{- (NSString *)stringByAppendingString:(NSString *)aString;}\n</code></pre><p>38.将多个字符串添加到前面字符串A的后面</p>\n<pre><code>{- (NSString *)stringByAppendingFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>39.只读属性 double类型</p>\n<pre><code>{@property (readonly)double doubleValue;}\n</code></pre><p>40.只读属性 float类型</p>\n<pre><code>{@property (readonly)float floatValue;}\n</code></pre><p>41.只读属性int类型</p>\n<pre><code>{@property (readonly)int intValue;}\n</code></pre><p>42.只读属性NSInteger类型</p>\n<pre><code>{@property (readonly)NSInteger integerValueNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>43.只读属性long long 类型</p>\n<pre><code>{@property (readonly)longlong longLongValueNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>44.只读属性BOOL类型</p>\n<pre><code>{@property (readonly)BOOL boolValueNS_AVAILABLE(10_5,2_0);} \n</code></pre><p>45.将字符串根据传进来的字符串参数separator进行分割，并转化成数组</p>\n<pre><code>{- (NSArray *)componentsSeparatedByString:(NSString *)separator;}\n</code></pre><p>46.将字符串根据传进来的字符编码separator进行分割，并拆分成数组返回</p>\n<pre><code>{- (NSArray *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separatorNS_AVAILABLE(10_5,2_0);}\n{- (NSString *)commonPrefixWithString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n</code></pre><p>47.将字符串的所有字符转化成大写</p>\n<pre><code>{@property (readonly,copy)NSString *uppercaseString;}\n</code></pre><p>48.将字符串的所有字符转化为小写</p>\n<pre><code>{@property (readonly,copy)NSString *lowercaseString;}\n</code></pre><p>49.所有单词的首字母转化成大写</p>\n<pre><code>{@property (readonly,copy)NSString *capitalizedString;}\n</code></pre><p>50.所有字符转化成大写 本地化</p>\n<pre><code>{- (NSString *)uppercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n</code></pre><p>51.所有字符串转化成小写 本地化</p>\n<pre><code>{- (NSString *)lowercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n</code></pre><p>52.所有单词首字母转化成大写 本地化</p>\n<pre><code>{- (NSString *)capitalizedStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n</code></pre><p>53.删除字符串中包含字符集部分的字符 返回字符串</p>\n<p>扩展一下，如果想要删除字符串前后的空格或者回车，这样做：</p>\n<pre><code>{[stringA stringByTrimmingCharactersInSet:  [NSCharacterSetWhitespaceAndNewLineCharacterSet]];\n\n- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;}\n</code></pre><p>54.将字符串padString指定索引段添加到前面字符串后面</p>\n<pre><code>{- (NSString *)stringByPaddingToLength:(NSUInteger)newLength withString:(NSString *)padString startingAtIndex:(NSUInteger)padIndex;}\n</code></pre><p>55.指定段分行去字符串</p>\n<pre><code>{- (void)getLineStart:(NSUInteger *)startPtr end:(NSUInteger *)lineEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n</code></pre><p>56.返回字符串指定段位置和长度</p>\n<pre><code>{- (NSRange)lineRangeForRange:(NSRange)range;}\n</code></pre><p>57.给字符串指定段分段取字符串</p>\n<pre><code>{- (void)getParagraphStart:(NSUInteger *)startPtr end:(NSUInteger *)parEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n</code></pre><p>58.指定段分段的位置和长度</p>\n<pre><code>{- (NSRange)paragraphRangeForRange:(NSRange)range;}\n</code></pre><p>59.</p>\n<pre><code>{typedefNS_OPTIONS(NSUInteger, NSStringEnumerationOptions) \n{\n\n// Pass in one of the &quot;By&quot; options:\n\nNSStringEnumerationByLines =0,                      // Equivalent to lineRangeForRange:\n\nNSStringEnumerationByParagraphs =1,                // Equivalent to paragraphRangeForRange:\n\nNSStringEnumerationByComposedCharacterSequences =2, //     Equivalent to rangeOfComposedCharacterSequencesForRange:\n\nNSStringEnumerationByWords =3,\n\nNSStringEnumerationBySentences =4,\n\n// ...and combine any of the desired additional options:\n\nNSStringEnumerationReverse =1UL &lt;&lt;8,\n\nNSStringEnumerationSubstringNotRequired =1UL &lt;&lt;9,\n\nNSStringEnumerationLocalized =1UL &lt;&lt;10            //     User&apos;s default locale\n\n};}\n</code></pre><p>60.检查是否在指定范围内是否有匹配的字符串</p>\n<pre><code>{- (void)enumerateSubstringsInRange:(NSRange)range options:(NSStringEnumerationOptions)opts usingBlock:(void (^)(NSString *substring,NSRange substringRange,NSRange enclosingRange, BOOL *stop))blockNS_AVAILABLE(10_6,4_0);}\n</code></pre><p>61.列举枚举字符串所有行</p>\n<pre><code>{- (void)enumerateLinesUsingBlock:(void (^)(NSString *line,BOOL *stop))block NS_AVAILABLE(10_6,4_0);}\n</code></pre><p>62.字符串</p>\n<pre><code>{@property (readonly,copy)NSString *description;}\n</code></pre><p>63.返回字符串哈希地址</p>\n<pre><code>{@property (readonly)NSUInteger hash;}\n</code></pre><p>64.字符串最快编码值</p>\n<pre><code>{@property (readonly)NSStringEncoding fastestEncoding;} \n</code></pre><p>65.字符串最小编码值</p>\n<pre><code>{@property (readonly)NSStringEncoding smallestEncoding; } \n</code></pre><p>66.返回指定编码的NSData对象</p>\n<pre><code>{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)lossy;  // External representation}\n</code></pre><p>67.返回指定编码的NSData对象</p>\n<pre><code>{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding;                                  // External representation}\n</code></pre><p>68.判断是否可以无损化转码</p>\n<pre><code>{- (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding;}\n</code></pre><p>69.char编码转化</p>\n<pre><code>{- (__strongconstchar *)cStringUsingEncoding:(NSStringEncoding)encodingNS_RETURNS_INNER_POINTER;}\n</code></pre><p>70.C字符串转化是够成功</p>\n<pre><code>{- (BOOL)getCString:(char *)buffer maxLength:(NSUInteger)maxBufferCount encoding:(NSStringEncoding)encoding;// NO return if conversion not}\n</code></pre><p>71.指定缓存区转换</p>\n<pre><code>{- (BOOL)getBytes:(void *)buffer maxLength:(NSUInteger)maxBufferCount usedLength:(NSUInteger *)usedBufferCount encoding:(NSStringEncoding)encoding options:(NSStringEncodingConversionOptions)options range:(NSRange)range remainingRange:(NSRangePointer)leftover;}\n</code></pre><p>72.字符串编码时需要用的字节长度</p>\n<pre><code>{- (NSUInteger)maximumLengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n</code></pre><p>73.字符串编码时需要用到最大字节长度</p>\n<pre><code>{- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n</code></pre><p>74.unicode范式D标准化</p>\n<pre><code>{@property (readonly,copy)NSString *decomposedStringWithCanonicalMapping;}\n</code></pre><p>75.unicode范式c标准化</p>\n<pre><code>{@property (readonly,copy)NSString *precomposedStringWithCanonicalMapping;}\n</code></pre><p>76.unicode范式KD标准化</p>\n<pre><code>{@property (readonly,copy)NSString *decomposedStringWithCompatibilityMapping;}\n</code></pre><p>77.unicode范式KC标准化</p>\n<pre><code>{@property (readonly,copy)NSString *precomposedStringWithCompatibilityMapping;}\n</code></pre><p>78.本地化字符串折叠</p>\n<pre><code>{- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale NS_AVAILABLE(10_5,2_0);}\n</code></pre><p>79.字符串的指定区域段被有条件的替换掉</p>\n<pre><code>{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:(NSStringCompareOptions)options range:(NSRange)searchRangeNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>80.字符串的特定字符串被替换掉</p>\n<pre><code>{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n</code></pre><p>81.将字符串的指定区域段字符串被替换掉</p>\n<pre><code>{- (NSString *)stringByReplacingCharactersInRange:(NSRange)range withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n</code></pre><p>82.将字符串转化为char类型</p>\n<pre><code>{@property (readonly)__strongconstchar *UTF8StringNS_RETURNS_INNER_POINTER;}\n</code></pre><p>83.默认C字符串编码</p>\n<pre><code>{+ (NSStringEncoding)defaultCStringEncoding;}\n</code></pre><p>84.可用的字符串编码</p>\n<pre><code>{+ (constNSStringEncoding *)availableStringEncodings;}\n</code></pre><p>85.编码的名称vheng</p>\n<pre><code>{+ (NSString *)localizedNameOfStringEncoding:(NSStringEncoding)encoding;}\n</code></pre><p>86.指定缓冲区，编码和字节长度初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithCharactersNoCopy:(unichar *)characters length:(NSUInteger)length freeWhenDone:(BOOL)freeBuffer;}\n</code></pre><p>87.指定unichar字符，字节长度初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n</code></pre><p>88.转化为NSString对象</p>\n<pre><code>{- (instancetype)initWithUTF8String:(constchar *)nullTerminatedCString;}\n</code></pre><p>89.指定字符串初始化为NSString对象</p>\n<pre><code>{- (instancetype)initWithString:(NSString *)aString;}\n</code></pre><p>90.格式化多个字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>91.格式化字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n</code></pre><p>92.本地化格式化多个字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale, ...NS_FORMAT_FUNCTION(1,3);}\n</code></pre><p>93.本地化格式化字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n</code></pre><p>94.指定编码转化NSData数据</p>\n<pre><code>{- (instancetype)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding;}\n</code></pre><p>95.指定编码和字节数初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithBytes:(constvoid *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding;}\n</code></pre><p>96.指定缓冲区，编码和字节数初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding freeWhenDone:(BOOL)freeBuffer;}\n</code></pre><p>97.初始化空字符串</p>\n<pre><code>{+ (instancetype)string;}\n</code></pre><p>98.初始化NSString字符串</p>\n<pre><code>{+ (instancetype)stringWithString:(NSString *)string;}\n</code></pre><p>99.返回指定长度unichar的C字符串</p>\n<pre><code>{+ (instancetype)stringWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n</code></pre><p>100.转化C字符串为UTF8串</p>\n<pre><code>{+ (instancetype)stringWithUTF8String:(constchar *)nullTerminatedCString;}\n</code></pre><p>101.初始化NSString对象昂，这种创建方式会自动释放内存，很常用的一种方式</p>\n<pre><code>{+ (instancetype)stringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>102.初始化NSString自动释放内存，本地化</p>\n<pre><code>{+ (instancetype)localizedStringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>103.初始化C字符串并且指定编码，在这里需要手动释放内存（init）</p>\n<pre><code>{- (instancetype)initWithCString:(constchar *)nullTerminatedCString encoding:(NSStringEncoding)encoding;}\n</code></pre><p>104.初始化C字符串并且指定编码，在这里需要自动释放内存</p>\n<pre><code>{+ (instancetype)stringWithCString:(constchar *)cString encoding:(NSStringEncoding)enc;}\n</code></pre><p>105.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，已经知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>106.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，已经知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>107.读取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，已经知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>108.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，已经知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>109.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，不知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>110.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，不知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>111.取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，不知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>112.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，不知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>113.将数据写入URL并且指定编码</p>\n<pre><code>{- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>114.将数据写入文件并且指定编码</p>\n<pre><code>{- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;\n\n@end\n\n@interface NSMutableString :NSString}\n</code></pre><p>115.使用aString替换前面字符串的指定区域字符</p>\n<pre><code>{- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;}\n</code></pre><p>@end</p>\n<p>116.可变字符串的扩展方法</p>\n<pre><code>{@interface NSMutableString (NSMutableStringExtensionMethods)}\n</code></pre><p>117.插入字符串aString，在指定的loc位置</p>\n<pre><code>{- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc;}\n</code></pre><p>118.删除指定区域段的字符串</p>\n<pre><code>{- (void)deleteCharactersInRange:(NSRange)range;}\n</code></pre><p>119.追加字符串aString</p>\n<pre><code>{- (void)appendString:(NSString *)aString;}\n</code></pre><p>120.追加多个字符串</p>\n<pre><code>{- (void)appendFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>121.设置新的aString</p>\n<pre><code>{- (void)setString:(NSString *)aString;}\n</code></pre><p>122.初始化一个容量为capacity大小的字符串，并且需要手动释放内存</p>\n<pre><code>{- (NSMutableString *)initWithCapacity:(NSUInteger)capacity;}\n</code></pre><p>123.初始化一个容量为capacity大小的字符串，但是不用手动释放内存，这些提前指定的容量，知识用于内存优化，实际大小可以大于设置的容量capacity</p>\n<pre><code>{+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;}\n</code></pre><p>124.指定限制条件，指定区段中的replacement替换成target</p>\n<pre><code>{- (NSUInteger)replaceOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:\n</code></pre><p>(NSStringCompareOptions)options range:(NSRange)searchRange;}</p>\n<p>@end</p>\n<p>125.关于字符串编码检测的扩展</p>\n<pre><code>{@interface NSString (NSStringEncodingDetection)}\n</code></pre><p>126.对一份data数据进行转换为字符串，有可选option字典，另外还有是否允许有损失，最终转换之后返回一个编码种类。下面是7种不同option字典选项</p>\n<pre><code>{+ (NSStringEncoding)stringEncodingForData:(NSData *)data\n\nencodingOptions:(NSDictionary *)opts\n\nconvertedString:(NSString **)string\n\nusedLossyConversion:(BOOL *)usedLossyConversion NS_AVAILABLE(10_10, 8_0);\n\n    @end\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionSuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n// NSArray of NSNumbers which contain NSStringEncoding values; if this key is not present in the dictionary, all encodings are considered\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionDisallowedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionUseOnlySuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n// NSNumber boolean value; if this key is not present in the dictionary, the default value is YES\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionAllowLossyKeyNS_AVAILABLE(10_10,8_0);\n\n// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionFromWindowsKeyNS_AVAILABLE(10_10,8_0);\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLossySubstitutionKeyNS_AVAILABLE(10_10,8_0);\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLikelyLanguageKeyNS_AVAILABLE(10_10,8_0);\n\n@interface NSString (NSExtendedStringPropertyListParsing)}\n</code></pre><p>127.将字符串转化为属性列表</p>\n<pre><code>{例如：NSString * stringA = [NSString stringWithFormat:@“Name =xulin ;\n\nage = 23;”];\n\nNSLog(@“%@”,[stringA  propertyList]);\n\n控制台输出为{\n\nName = xulin ;\n\nage = 23;\n\n}\n\n- (id)propertyList;}\n</code></pre><p>128.字符串转化为字典</p>\n<pre><code>{NSDictionary * dictionary  = [stringA propertyListFromStringFileFormat];\n\nNSLog(@“%@”,dictionary);\n\n控制台输出为{\n\nName = xulin ;\n\nage = 23;\n\n}\n\n- (NSDictionary *)propertyListFromStringsFileFormat\n\n@end}\n</code></pre><p>129.下面是一些弃用代码。也就是上面所翻译过的代码。</p>\n<pre><code>{@interface NSString (NSStringDeprecated)\n\n- (constchar *)cStringNS_RETURNS_INNER_POINTERNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (constchar *)lossyCStringNS_RETURNS_INNER_POINTER NS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (NSUInteger)cStringLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCString:(char *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLength range:(NSRange)aRange remainingRange:(NSRangePointer)leftoverRange NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);\n\n- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFileNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomicallyNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithCStringNoCopy:(char *)bytes length:(NSUInteger)length freeWhenDone:(BOOL)freeBufferNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCharacters:(unichar *)buffer;\n\n@end\n\nenum {\n\nNSProprietaryStringEncoding =65536  /* Installation-specific encoding */\n\n};\n\n#if !defined(_OBJC_UNICHAR_H_)\n\n#define _OBJC_UNICHAR_H_\n\n#endif\n\n#define NS_UNICHAR_IS_EIGHT_BIT 0\n\n@interface NSSimpleCString :NSString {\n\n@package\n\nchar *bytes;\n\nint numBytes;\n\n#if __LP64__\n\nint _unused;\n\n#endif\n\n}\n\n@end\n\n@interface NSConstantString :NSSimpleCString\n\n@end\n\n#if __LP64__\n\n#else\n\nexternvoid *_NSConstantStringClassReference;\n\n#endif\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>iOS8最新API和一些生僻API，做了红色标注，便于大家查阅</p>\n<p>0.定义一个无符号整型 两个字节 范围[0,65535] </p>\n<pre><code>{typedef unsigned short unichar;}\n</code></pre>","more":"<p>1.提前进入以下六个类告诉编译器，六个都是类的名称 </p>\n<p>@class NSData,NSArray,NSDictionary,NSCharacterSet,NSURL,NSError,NSLocale;</p>\n<p>2.异常处理字符串，控制台出错信息报告 </p>\n<pre><code>{FOUNDATION_EXPORTNSString *const NSParseErrorException;} \n</code></pre><p>3.宏定义下字符串的最大值 </p>\n<pre><code>{#define NSMaximumStringLength (INT_MAX-1)} \n</code></pre><p>4.字符串进行比较</p>\n<p>options typedef NS_OPTIONS(NSUInteger,     NSStringCompareOptions)<br>    {<br>    NSCaseInsensitiveSearch =1,//    两个 字符串的比较不区分大小写             NSLiteralSearch = 2,//两个字符串的    比较区分大小写         NSBackwardsSearch =4,//从字符串末尾开发查询搜索<br>    NSAnchoredSearch =8,//搜索有限制范围的字符串<br>    NSNumericSearch =     64,//根据字符串里的数字来计算顺序        NSDiacriticInsensitiveSearchNS_ENUM_AVAILABLE(10_5,2_0)     =128,  NSWidthInsensitiveSearch             NS_ENUM_AVAILABLE(10_5,2_0) =256,//可以忽略字符串的宽度（长度）    比较结果<br>    NSForcedOrderingSearchNS_ENUM_AVAILABLE(10_5,2_0) =512,//    忽略不区分大小写比较的选项                        NSRegularExpressionSearchNS_ENUM_AVAILABLE(10_7,3_2)     =1024 //  };</p>\n<p>5.字符串编码的多种选项 </p>\n<p>enum {<br>NSASCIIStringEncoding =1,/<em> 0..127 only </em>/    NSNEXTSTEPStringEncoding =2,<br>NSJapaneseEUCStringEncoding =3,<br>NSUTF8StringEncoding =4,<br>NSISOLatin1StringEncoding =5,<br>NSSymbolStringEncoding =6,<br>NSNonLossyASCIIStringEncoding =7,<br>NSShiftJISStringEncoding =8, /<em> kCFStringEncodingDOSJapanese </em>/<br>NSISOLatin2StringEncoding =9,<br>NSUnicodeStringEncoding =10,<br>NSWindowsCP1251StringEncoding = 11,  /<em> Cyrillic; same as AdobeStandardCyrillic </em>/<br>NSWindowsCP1252StringEncoding =12,  /<em> WinLatin1 </em>/    NSWindowsCP1253StringEncoding =13,  /<em> Greek </em>/    NSWindowsCP1254StringEncoding =14,  /<em> Turkish </em>/    NSWindowsCP1250StringEncoding =15,  /<em> WinLatin2 </em>/    NSISO2022JPStringEncoding = 21,      /<em> ISO 2022 Japanese encoding for e-mail </em>/<br>NSMacOSRomanStringEncoding =30,<br>NSUTF16StringEncoding = NSUnicodeStringEncoding,    /<em> An alias for NSUnicodeStringEncoding </em>/    NSUTF16BigEndianStringEncoding = 0x90000100,        /<em> NSUTF16StringEncoding encoding with explicit endianness specified </em>/<br>NSUTF16LittleEndianStringEncoding = 0x94000100,      /<em> NSUTF16StringEncoding encoding with explicit endianness specified </em>/<br>NSUTF32StringEncoding =0x8c000100,                        NSUTF32BigEndianStringEncoding = 0x98000100,        /<em> NSUTF32StringEncoding encoding with explicit endianness specified </em>/<br>NSUTF32LittleEndianStringEncoding = 0x9c000100      /<em> NSUTF32StringEncoding encoding with explicit endianness specified </em>/ }; </p>\n<p>6.字符串编码 </p>\n<pre><code>{typedefNSUInteger NSStringEncoding;}   \n</code></pre><p>字符串编码转换条件option，下面指定缓冲区转换会用到 </p>\n<pre><code>{\ntypedef NS_OPTIONS(NSUInteger, NSStringEncodingConversionOptions) {    NSStringEncodingConversionAllowLossy =1,    NSStringEncodingConversionExternalRepresentation =2 }; //7.字符转化异常 FOUNDATION_EXPORTNSString *const NSCharacterConversionException; //8. NSString继承NSObject，并遵守以下三个协议 @interface NSString :NSObject//9.只读属性字符串长度length\n@property (readonly)NSUInteger length;\n}\n</code></pre><p>7.选取字符串对应下表的字符</p>\n<pre><code>{\n-(unichar)characterAtIndex:(NSUInteger)index;}\n</code></pre><p>8.字符串的init初始化方法</p>\n<pre><code>{-(instancetype)initNS_DESIGNATED_INITIALIZER;}\n</code></pre><p>9.当一个xib的控件被加载实例化的时候，系统会默认调用这个方法。</p>\n<pre><code>{- (instancetype)initWithCoder:(NSCoder *)aDecoderNS_DESIGNATED_INITIALIZER;}\n</code></pre><p>10.NSString的扩展方法</p>\n<pre><code>{@interface NSString (NSStringExtensionMethods)}\n</code></pre><p>11.截取字符串的指定段</p>\n<pre><code>{- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange;}\n</code></pre><p>12.截取指定位置Index之后字符串</p>\n<pre><code>{- (NSString *)substringFromIndex:(NSUInteger)from;}\n</code></pre><p>13.从索引0第一个字符串开始，截取指定长度的字符串</p>\n<pre><code>{- (NSString *)substringToIndex:(NSUInteger)to;}\n</code></pre><p>14.截取字符串的指定段，返回值为NSString</p>\n<pre><code>{- (NSString *)substringWithRange:(NSRange)range;}\n</code></pre><p>15.比较两个字符串</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string;}\n</code></pre><p>16.比较两个字符串，并加上条件</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;}\n</code></pre><p>17.比较两个字符串，并加上某些条件到指定段</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange;}\n</code></pre><p>18.比较两个字符串，并加上某些条件还有本地化语言环境，在指定段进行比较</p>\n<pre><code>{- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange locale:(id)locale;}\n</code></pre><p>19.不区分大小写比较字符串</p>\n<pre><code>{- (NSComparisonResult)caseInsensitiveCompare:(NSString *)string;}\n</code></pre><p>20.本地化比较字符串</p>\n<pre><code>{- (NSComparisonResult)localizedCompare:(NSString *)string;}\n</code></pre><p>21.不区分大小写以及本地化比较字符串</p>\n<pre><code>{- (NSComparisonResult)localizedCaseInsensitiveCompare:(NSString *)string;}\n</code></pre><p>22.本地化标准字符串比较，返回升序降序相等</p>\n<pre><code>{- (NSComparisonResult)localizedStandardCompare:(NSString *)stringNS_AVAILABLE(10_6,4_0);}\n</code></pre><p>23.比较两个字符串是否相等</p>\n<pre><code>{- (BOOL)isEqualToString:(NSString *)aString;}\n</code></pre><p>24.测试字符串是否以aString开头</p>\n<pre><code>{- (BOOL)hasPrefix:(NSString *)aString;}\n</code></pre><p>25.测试字符串是否以aString结尾</p>\n<pre><code>{- (BOOL)hasSuffix:(NSString *)aString;}\n</code></pre><p>26.判断字符串A是否包含aString字符串B，返回值Bool</p>\n<pre><code>{- (BOOL)containsString:(NSString *)aStringNS_AVAILABLE(10_10,8_0);}\n</code></pre><p>27.这是iOS8的新特性API 判断字符串A是否包含字符串B，不区分大小写，返回Bool</p>\n<p> 例：</p>\n<pre><code>{\nNSSsring * stringA = @“abcd”;\n\nNSSsring * stringB = @“d”;\n\nBOOl  test = [stringA localizedCaseInsensitiveContainsString:stringB];\n\n输出打印值 YES\n\n- (BOOL)localizedCaseInsensitiveContainsString:(NSString *)aString NS_AVAILABLE(10_10, 8_0);}\n</code></pre><p>28.搜索一个字符串是否包含某个字符 rangeOfString前面的参数是要被搜索的字符串，后面的是要搜索的字符</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString;}\n</code></pre><p>29.搜索一个字符串是否包含某个字符，并添加筛选条件option</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n</code></pre><p>30.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n</code></pre><p>31.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range,最后还有本地化的设置</p>\n<pre><code>{- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)localeNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>32.指定字符集进行搜索</p>\n<pre><code>{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet;}\n</code></pre><p>33.指定字符集进行搜索，并且加上某些限制条件</p>\n<pre><code>{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask;}\n</code></pre><p>34.指定字符集进行搜索，并且加上某些限制条件，且在指定的位置段进行</p>\n<pre><code>{- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)searchRange;}\n</code></pre><p>35.用字符串的字符编码指定索引查找位置</p>\n<pre><code>{- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;}\n</code></pre><p>36.用字符串的字符编码指定区域段查找位置</p>\n<pre><code>{- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)rangeNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>37.将aString字符串添加到前面字符串A的后面</p>\n<pre><code>{- (NSString *)stringByAppendingString:(NSString *)aString;}\n</code></pre><p>38.将多个字符串添加到前面字符串A的后面</p>\n<pre><code>{- (NSString *)stringByAppendingFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>39.只读属性 double类型</p>\n<pre><code>{@property (readonly)double doubleValue;}\n</code></pre><p>40.只读属性 float类型</p>\n<pre><code>{@property (readonly)float floatValue;}\n</code></pre><p>41.只读属性int类型</p>\n<pre><code>{@property (readonly)int intValue;}\n</code></pre><p>42.只读属性NSInteger类型</p>\n<pre><code>{@property (readonly)NSInteger integerValueNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>43.只读属性long long 类型</p>\n<pre><code>{@property (readonly)longlong longLongValueNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>44.只读属性BOOL类型</p>\n<pre><code>{@property (readonly)BOOL boolValueNS_AVAILABLE(10_5,2_0);} \n</code></pre><p>45.将字符串根据传进来的字符串参数separator进行分割，并转化成数组</p>\n<pre><code>{- (NSArray *)componentsSeparatedByString:(NSString *)separator;}\n</code></pre><p>46.将字符串根据传进来的字符编码separator进行分割，并拆分成数组返回</p>\n<pre><code>{- (NSArray *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separatorNS_AVAILABLE(10_5,2_0);}\n{- (NSString *)commonPrefixWithString:(NSString *)aString options:(NSStringCompareOptions)mask;}\n</code></pre><p>47.将字符串的所有字符转化成大写</p>\n<pre><code>{@property (readonly,copy)NSString *uppercaseString;}\n</code></pre><p>48.将字符串的所有字符转化为小写</p>\n<pre><code>{@property (readonly,copy)NSString *lowercaseString;}\n</code></pre><p>49.所有单词的首字母转化成大写</p>\n<pre><code>{@property (readonly,copy)NSString *capitalizedString;}\n</code></pre><p>50.所有字符转化成大写 本地化</p>\n<pre><code>{- (NSString *)uppercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n</code></pre><p>51.所有字符串转化成小写 本地化</p>\n<pre><code>{- (NSString *)lowercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n</code></pre><p>52.所有单词首字母转化成大写 本地化</p>\n<pre><code>{- (NSString *)capitalizedStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);}\n</code></pre><p>53.删除字符串中包含字符集部分的字符 返回字符串</p>\n<p>扩展一下，如果想要删除字符串前后的空格或者回车，这样做：</p>\n<pre><code>{[stringA stringByTrimmingCharactersInSet:  [NSCharacterSetWhitespaceAndNewLineCharacterSet]];\n\n- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;}\n</code></pre><p>54.将字符串padString指定索引段添加到前面字符串后面</p>\n<pre><code>{- (NSString *)stringByPaddingToLength:(NSUInteger)newLength withString:(NSString *)padString startingAtIndex:(NSUInteger)padIndex;}\n</code></pre><p>55.指定段分行去字符串</p>\n<pre><code>{- (void)getLineStart:(NSUInteger *)startPtr end:(NSUInteger *)lineEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n</code></pre><p>56.返回字符串指定段位置和长度</p>\n<pre><code>{- (NSRange)lineRangeForRange:(NSRange)range;}\n</code></pre><p>57.给字符串指定段分段取字符串</p>\n<pre><code>{- (void)getParagraphStart:(NSUInteger *)startPtr end:(NSUInteger *)parEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;}\n</code></pre><p>58.指定段分段的位置和长度</p>\n<pre><code>{- (NSRange)paragraphRangeForRange:(NSRange)range;}\n</code></pre><p>59.</p>\n<pre><code>{typedefNS_OPTIONS(NSUInteger, NSStringEnumerationOptions) \n{\n\n// Pass in one of the &quot;By&quot; options:\n\nNSStringEnumerationByLines =0,                      // Equivalent to lineRangeForRange:\n\nNSStringEnumerationByParagraphs =1,                // Equivalent to paragraphRangeForRange:\n\nNSStringEnumerationByComposedCharacterSequences =2, //     Equivalent to rangeOfComposedCharacterSequencesForRange:\n\nNSStringEnumerationByWords =3,\n\nNSStringEnumerationBySentences =4,\n\n// ...and combine any of the desired additional options:\n\nNSStringEnumerationReverse =1UL &lt;&lt;8,\n\nNSStringEnumerationSubstringNotRequired =1UL &lt;&lt;9,\n\nNSStringEnumerationLocalized =1UL &lt;&lt;10            //     User&apos;s default locale\n\n};}\n</code></pre><p>60.检查是否在指定范围内是否有匹配的字符串</p>\n<pre><code>{- (void)enumerateSubstringsInRange:(NSRange)range options:(NSStringEnumerationOptions)opts usingBlock:(void (^)(NSString *substring,NSRange substringRange,NSRange enclosingRange, BOOL *stop))blockNS_AVAILABLE(10_6,4_0);}\n</code></pre><p>61.列举枚举字符串所有行</p>\n<pre><code>{- (void)enumerateLinesUsingBlock:(void (^)(NSString *line,BOOL *stop))block NS_AVAILABLE(10_6,4_0);}\n</code></pre><p>62.字符串</p>\n<pre><code>{@property (readonly,copy)NSString *description;}\n</code></pre><p>63.返回字符串哈希地址</p>\n<pre><code>{@property (readonly)NSUInteger hash;}\n</code></pre><p>64.字符串最快编码值</p>\n<pre><code>{@property (readonly)NSStringEncoding fastestEncoding;} \n</code></pre><p>65.字符串最小编码值</p>\n<pre><code>{@property (readonly)NSStringEncoding smallestEncoding; } \n</code></pre><p>66.返回指定编码的NSData对象</p>\n<pre><code>{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)lossy;  // External representation}\n</code></pre><p>67.返回指定编码的NSData对象</p>\n<pre><code>{- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding;                                  // External representation}\n</code></pre><p>68.判断是否可以无损化转码</p>\n<pre><code>{- (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding;}\n</code></pre><p>69.char编码转化</p>\n<pre><code>{- (__strongconstchar *)cStringUsingEncoding:(NSStringEncoding)encodingNS_RETURNS_INNER_POINTER;}\n</code></pre><p>70.C字符串转化是够成功</p>\n<pre><code>{- (BOOL)getCString:(char *)buffer maxLength:(NSUInteger)maxBufferCount encoding:(NSStringEncoding)encoding;// NO return if conversion not}\n</code></pre><p>71.指定缓存区转换</p>\n<pre><code>{- (BOOL)getBytes:(void *)buffer maxLength:(NSUInteger)maxBufferCount usedLength:(NSUInteger *)usedBufferCount encoding:(NSStringEncoding)encoding options:(NSStringEncodingConversionOptions)options range:(NSRange)range remainingRange:(NSRangePointer)leftover;}\n</code></pre><p>72.字符串编码时需要用的字节长度</p>\n<pre><code>{- (NSUInteger)maximumLengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n</code></pre><p>73.字符串编码时需要用到最大字节长度</p>\n<pre><code>{- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;}\n</code></pre><p>74.unicode范式D标准化</p>\n<pre><code>{@property (readonly,copy)NSString *decomposedStringWithCanonicalMapping;}\n</code></pre><p>75.unicode范式c标准化</p>\n<pre><code>{@property (readonly,copy)NSString *precomposedStringWithCanonicalMapping;}\n</code></pre><p>76.unicode范式KD标准化</p>\n<pre><code>{@property (readonly,copy)NSString *decomposedStringWithCompatibilityMapping;}\n</code></pre><p>77.unicode范式KC标准化</p>\n<pre><code>{@property (readonly,copy)NSString *precomposedStringWithCompatibilityMapping;}\n</code></pre><p>78.本地化字符串折叠</p>\n<pre><code>{- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale NS_AVAILABLE(10_5,2_0);}\n</code></pre><p>79.字符串的指定区域段被有条件的替换掉</p>\n<pre><code>{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:(NSStringCompareOptions)options range:(NSRange)searchRangeNS_AVAILABLE(10_5,2_0);}\n</code></pre><p>80.字符串的特定字符串被替换掉</p>\n<pre><code>{- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n</code></pre><p>81.将字符串的指定区域段字符串被替换掉</p>\n<pre><code>{- (NSString *)stringByReplacingCharactersInRange:(NSRange)range withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);}\n</code></pre><p>82.将字符串转化为char类型</p>\n<pre><code>{@property (readonly)__strongconstchar *UTF8StringNS_RETURNS_INNER_POINTER;}\n</code></pre><p>83.默认C字符串编码</p>\n<pre><code>{+ (NSStringEncoding)defaultCStringEncoding;}\n</code></pre><p>84.可用的字符串编码</p>\n<pre><code>{+ (constNSStringEncoding *)availableStringEncodings;}\n</code></pre><p>85.编码的名称vheng</p>\n<pre><code>{+ (NSString *)localizedNameOfStringEncoding:(NSStringEncoding)encoding;}\n</code></pre><p>86.指定缓冲区，编码和字节长度初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithCharactersNoCopy:(unichar *)characters length:(NSUInteger)length freeWhenDone:(BOOL)freeBuffer;}\n</code></pre><p>87.指定unichar字符，字节长度初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n</code></pre><p>88.转化为NSString对象</p>\n<pre><code>{- (instancetype)initWithUTF8String:(constchar *)nullTerminatedCString;}\n</code></pre><p>89.指定字符串初始化为NSString对象</p>\n<pre><code>{- (instancetype)initWithString:(NSString *)aString;}\n</code></pre><p>90.格式化多个字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>91.格式化字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n</code></pre><p>92.本地化格式化多个字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale, ...NS_FORMAT_FUNCTION(1,3);}\n</code></pre><p>93.本地化格式化字符串初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithFormat:(NSString *)format locale:(id)locale arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);}\n</code></pre><p>94.指定编码转化NSData数据</p>\n<pre><code>{- (instancetype)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding;}\n</code></pre><p>95.指定编码和字节数初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithBytes:(constvoid *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding;}\n</code></pre><p>96.指定缓冲区，编码和字节数初始化NSString对象</p>\n<pre><code>{- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding freeWhenDone:(BOOL)freeBuffer;}\n</code></pre><p>97.初始化空字符串</p>\n<pre><code>{+ (instancetype)string;}\n</code></pre><p>98.初始化NSString字符串</p>\n<pre><code>{+ (instancetype)stringWithString:(NSString *)string;}\n</code></pre><p>99.返回指定长度unichar的C字符串</p>\n<pre><code>{+ (instancetype)stringWithCharacters:(constunichar *)characters length:(NSUInteger)length;}\n</code></pre><p>100.转化C字符串为UTF8串</p>\n<pre><code>{+ (instancetype)stringWithUTF8String:(constchar *)nullTerminatedCString;}\n</code></pre><p>101.初始化NSString对象昂，这种创建方式会自动释放内存，很常用的一种方式</p>\n<pre><code>{+ (instancetype)stringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>102.初始化NSString自动释放内存，本地化</p>\n<pre><code>{+ (instancetype)localizedStringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>103.初始化C字符串并且指定编码，在这里需要手动释放内存（init）</p>\n<pre><code>{- (instancetype)initWithCString:(constchar *)nullTerminatedCString encoding:(NSStringEncoding)encoding;}\n</code></pre><p>104.初始化C字符串并且指定编码，在这里需要自动释放内存</p>\n<pre><code>{+ (instancetype)stringWithCString:(constchar *)cString encoding:(NSStringEncoding)enc;}\n</code></pre><p>105.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，已经知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>106.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，已经知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>107.读取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，已经知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>108.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，已经知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>109.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，不知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>110.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，不知道编码</p>\n<pre><code>{- (instancetype)initWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>111.取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，不知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>112.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，不知道编码</p>\n<pre><code>{+ (instancetype)stringWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;}\n</code></pre><p>113.将数据写入URL并且指定编码</p>\n<pre><code>{- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;}\n</code></pre><p>114.将数据写入文件并且指定编码</p>\n<pre><code>{- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;\n\n@end\n\n@interface NSMutableString :NSString}\n</code></pre><p>115.使用aString替换前面字符串的指定区域字符</p>\n<pre><code>{- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;}\n</code></pre><p>@end</p>\n<p>116.可变字符串的扩展方法</p>\n<pre><code>{@interface NSMutableString (NSMutableStringExtensionMethods)}\n</code></pre><p>117.插入字符串aString，在指定的loc位置</p>\n<pre><code>{- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc;}\n</code></pre><p>118.删除指定区域段的字符串</p>\n<pre><code>{- (void)deleteCharactersInRange:(NSRange)range;}\n</code></pre><p>119.追加字符串aString</p>\n<pre><code>{- (void)appendString:(NSString *)aString;}\n</code></pre><p>120.追加多个字符串</p>\n<pre><code>{- (void)appendFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);}\n</code></pre><p>121.设置新的aString</p>\n<pre><code>{- (void)setString:(NSString *)aString;}\n</code></pre><p>122.初始化一个容量为capacity大小的字符串，并且需要手动释放内存</p>\n<pre><code>{- (NSMutableString *)initWithCapacity:(NSUInteger)capacity;}\n</code></pre><p>123.初始化一个容量为capacity大小的字符串，但是不用手动释放内存，这些提前指定的容量，知识用于内存优化，实际大小可以大于设置的容量capacity</p>\n<pre><code>{+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;}\n</code></pre><p>124.指定限制条件，指定区段中的replacement替换成target</p>\n<pre><code>{- (NSUInteger)replaceOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:\n</code></pre><p>(NSStringCompareOptions)options range:(NSRange)searchRange;}</p>\n<p>@end</p>\n<p>125.关于字符串编码检测的扩展</p>\n<pre><code>{@interface NSString (NSStringEncodingDetection)}\n</code></pre><p>126.对一份data数据进行转换为字符串，有可选option字典，另外还有是否允许有损失，最终转换之后返回一个编码种类。下面是7种不同option字典选项</p>\n<pre><code>{+ (NSStringEncoding)stringEncodingForData:(NSData *)data\n\nencodingOptions:(NSDictionary *)opts\n\nconvertedString:(NSString **)string\n\nusedLossyConversion:(BOOL *)usedLossyConversion NS_AVAILABLE(10_10, 8_0);\n\n    @end\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionSuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n// NSArray of NSNumbers which contain NSStringEncoding values; if this key is not present in the dictionary, all encodings are considered\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionDisallowedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionUseOnlySuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0);\n\n// NSNumber boolean value; if this key is not present in the dictionary, the default value is YES\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionAllowLossyKeyNS_AVAILABLE(10_10,8_0);\n\n// NSNumber boolean value; if this key is not present in the dictionary, the default value is NO\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionFromWindowsKeyNS_AVAILABLE(10_10,8_0);\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLossySubstitutionKeyNS_AVAILABLE(10_10,8_0);\n\nFOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLikelyLanguageKeyNS_AVAILABLE(10_10,8_0);\n\n@interface NSString (NSExtendedStringPropertyListParsing)}\n</code></pre><p>127.将字符串转化为属性列表</p>\n<pre><code>{例如：NSString * stringA = [NSString stringWithFormat:@“Name =xulin ;\n\nage = 23;”];\n\nNSLog(@“%@”,[stringA  propertyList]);\n\n控制台输出为{\n\nName = xulin ;\n\nage = 23;\n\n}\n\n- (id)propertyList;}\n</code></pre><p>128.字符串转化为字典</p>\n<pre><code>{NSDictionary * dictionary  = [stringA propertyListFromStringFileFormat];\n\nNSLog(@“%@”,dictionary);\n\n控制台输出为{\n\nName = xulin ;\n\nage = 23;\n\n}\n\n- (NSDictionary *)propertyListFromStringsFileFormat\n\n@end}\n</code></pre><p>129.下面是一些弃用代码。也就是上面所翻译过的代码。</p>\n<pre><code>{@interface NSString (NSStringDeprecated)\n\n- (constchar *)cStringNS_RETURNS_INNER_POINTERNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (constchar *)lossyCStringNS_RETURNS_INNER_POINTER NS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (NSUInteger)cStringLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCString:(char *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLength range:(NSRange)aRange remainingRange:(NSRangePointer)leftoverRange NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);\n\n- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFileNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomicallyNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithCStringNoCopy:(char *)bytes length:(NSUInteger)length freeWhenDone:(BOOL)freeBufferNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (id)initWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n+ (id)stringWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0);\n\n- (void)getCharacters:(unichar *)buffer;\n\n@end\n\nenum {\n\nNSProprietaryStringEncoding =65536  /* Installation-specific encoding */\n\n};\n\n#if !defined(_OBJC_UNICHAR_H_)\n\n#define _OBJC_UNICHAR_H_\n\n#endif\n\n#define NS_UNICHAR_IS_EIGHT_BIT 0\n\n@interface NSSimpleCString :NSString {\n\n@package\n\nchar *bytes;\n\nint numBytes;\n\n#if __LP64__\n\nint _unused;\n\n#endif\n\n}\n\n@end\n\n@interface NSConstantString :NSSimpleCString\n\n@end\n\n#if __LP64__\n\n#else\n\nexternvoid *_NSConstantStringClassReference;\n\n#endif\n}\n</code></pre>"},{"title":"性能检测要怎么玩才尽兴","date":"2017-07-06T08:18:35.000Z","_content":"\n前言:   相信大家平时在利用xcode调试bug的时候经常性的遇到一些莫名其妙的问题，其中就包括崩溃了，打全局断点也不崩溃到某一行，而是直接报野指针的问题，像这种不能具体定位到错误在某一行的代码是最难找到问题的。现在我们可以通过打全局断点，然后xcode自带的内存检测工具来找到问题可能出现的地方。\n\n打开一个XCode项目，最好是连上真机来测试，这里如果你xcode已经升级到了8.0以上，那么你就必须要有证书才能进行真机调试了。如果在XCode7上面，你是可以直接进行真机测试的。连上手机以后，选择produc->profile进入XCode自带的调试工具选择页面。\n<!-- more -->\n\n如下图:\n![image](http://upload-images.jianshu.io/upload_images/1863813-5af1b48f8e6ac255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n选择完以后的样式如下图:\n![image](http://upload-images.jianshu.io/upload_images/1863813-6d5c0ef5154f99aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们可以从上面看到箭头所指的四个地方，一个是Allocations->这个是关于UI布局方面的检测，第二个是Core Animation 这个是关于动画方面的检测，通过Core Animation可以检测到他的帧数，从而判断是不是卡，是否需要进一步完善动画。第三个Leaks就是我们用的最多的内存泄露检测，通过这个，我们可以大致锁定哪些地方可能有内存泄露，然后直接找到有内存泄露的地方，这样可以非常方便我们找到哪里有问题。第四个Time Profiler 这个是检测事件的工具，比如按钮的触发事件等等这些。接下来讲解如何使用它们。\n\n\n这里列举如何使用Leaks这个内存检测工具。\n\n1.首先点开Leaks这个工具，然后选中左上角的Leaks检测选项\n\n2.点击开始运行\n\n3.选择Call tress以一个树形结构来展示\n\n4.在右下角Call Tree选项中选择Separate by Thread 和 Hide System Libraries这两个，其他的展示没研究深刻，没用过，这样我们点击页面就可以看到那些地方有问题，然后我们双击有问题的那个类，就可以找到对应的代码，通过进入xcode去检查就行了。\n\n如图:\n![image](http://upload-images.jianshu.io/upload_images/1863813-b1a96a5a6406a6a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n通过上面的过程以后双击6步骤得到结果如下:\n![image](http://upload-images.jianshu.io/upload_images/1863813-b85f9992e813b53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们可以看到在第一步中我们能看到哪里有问题，然后点击步骤二，就可以直接到达XCode中，这句代码对应的地方，这样就可以找到可能有问题的地方，从而检查出我们项目是否有问题了。\n\n检测动画方面，其实方法也差不多，只是选项不太一样而已。最后选项如图：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-a0912cddcf64e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们需要了解两个两个区域：\n\n这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动\n\n这是重中之重，接下来我会带大家逐个理解、体验这些调试选项\n\n有过游戏经验的人也许对fps这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。根据不同选项可以找到问题，这里我们一项一项的来为大家讲解每一项代表的意思.\n\n1.Color Blended Layers 这个是图层颜色混合的意思.\n\n基本概念:\n\n我们要明白 像素 的概念。屏幕上每一个点都是一个像素点，颜色由R、G、B、alpha组成。如果某一块区域上覆盖了多层layer，最后所计算出来的显示的颜色效果，会受到这些layer的共同影响。举个例子：上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blended)需要消耗一定的GPU资源，在实际开发中可能不止只有两层。如果只想显示最上层的颜色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。\n\nCore Animation Instrucment\n\n类似如下图，可以通过Instrucments来选择Core Animation查看FPS：\n![image](http://upload-images.jianshu.io/upload_images/1863813-8d674ad619395bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n注意:如果要看FPS,需要在真机上运行\n\nDemo优化前\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-915c54bd34f15c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在优化之前，我们通过设置如下方式，可以看到有好多混合的地方，红色部分都是影响滚动时流畅性的。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-b43a2d72946904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nDemo优化后\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-aafaecbaa6be149c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n优化后，我们看到没有中文标签变成绿色了，而有中文的标签还是混合后的颜色。关于有中文的标签如何去优化，这个问题现在没有办法，如果大家有什么好的方法，请一定要告诉我。\n\n优化的代码\n\n在优化前，cell的标题的背景颜色并没有手动设置，而是使用了默认的颜色，这时候即使我们的标题是没有中文的，也会出现混合。而笔者只是添加了一行代码：\n\n\t{self.titleLabel.backgroundColor = self.contentView.backgroundColor;}\n \n这么一行代码，使得标签的背景色和父视图的背景颜色一样，就只可以解决混合的问题（中文除外）。 如何我们设置背景色为clear，一样会出现混合，即使父视图也是clear。\n\n同样，我们在配置CollectionViewCell的时候，也是这么处理：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-90fa702d5a85abe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们设置cell的背景色、collectionview的背景色都为白色，然后titleLabel的背景色与父视图的背景色设置成一样，这样就可以解决混合问题，中文文本除外。\n\n我们尝试设置opaque、alpha都会是图层混合，因此最关键的还是backgroundColor这一关键属性。在实际开发中海油很多控件需要我们注意，这里只是简单介绍。\n\n2.Color Hits Green and Misses Red 光栅化\n\n光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：\n\n\t\t{label.layer.shouldRasterize = YES;}\n\n如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。\n\n光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：\n\n上下微小幅度滑动时，一直是绿色\n\n上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色\n\n如果静止一秒钟，刚开始滑动时会变红。\n\n这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。\n\n光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：\n   \n\t{label.layer.shouldRasterize = YES;}  \n光栅化会  导致离屏渲染，这个下面会讲解。\n\n概念理解\n\nOpenGL中，GPU屏幕渲染有以下两种方式：\n\nOn-Screen Rendering\n\n意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。\n\nOff-Screen Rendering\n\n意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n\n离屏渲染的是是非非\n\n相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：\n\n1.创建新缓冲区；要想进行离屏渲染，首先要创建一个新的缓冲区。\n\n2上下文切换；离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。\n\n离屏渲染触发方式\n\n设置了以下属性时，都会触发离屏绘制：\n\nshouldRasterize（光栅化）\n\nmasks（遮罩）\n\nshadows（阴影）\n\nedge antialiasing（抗锯齿）\n\ngroup opacity（不透明）\n\n需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：cpu渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。\n\n3.Color Offscreen Rendered Yellow 开启以后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。如下图:\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-8b3c71cd6b2a151e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-5269d74977a462ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。\n\n设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-69c5f7ffad543d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n4.Color Copied images 这个是用来检测图片的格式转化的，比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。如果调试时发现有图片被标记为蓝色，说明图片格式有问题。\n\n5.Color Misaligned images 意思就是当图片的像素和目标控件的像素不对齐，就会放一个洋红色的图层在图片上，当图片的像素大小与控件的大小不一致而导致需要缩放时，图片会呈现黄色。\n\n6.Color Compositing Fast Path Blue 标记由硬件标记的路径。蓝色越多越好。\n\n7.Flash Updated Regions 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。\n\n                     注:文章灵感来自同事，如有转载，请注明出处；谢谢。","source":"_posts/性能检测要怎么玩才尽兴/性能检测要怎么玩才尽兴.md","raw":"---\ntitle: 性能检测要怎么玩才尽兴\ndate: 2017-07-06 16:18:35\ntags:\n  - Instruments \n  - 性能检测\n---\n\n前言:   相信大家平时在利用xcode调试bug的时候经常性的遇到一些莫名其妙的问题，其中就包括崩溃了，打全局断点也不崩溃到某一行，而是直接报野指针的问题，像这种不能具体定位到错误在某一行的代码是最难找到问题的。现在我们可以通过打全局断点，然后xcode自带的内存检测工具来找到问题可能出现的地方。\n\n打开一个XCode项目，最好是连上真机来测试，这里如果你xcode已经升级到了8.0以上，那么你就必须要有证书才能进行真机调试了。如果在XCode7上面，你是可以直接进行真机测试的。连上手机以后，选择produc->profile进入XCode自带的调试工具选择页面。\n<!-- more -->\n\n如下图:\n![image](http://upload-images.jianshu.io/upload_images/1863813-5af1b48f8e6ac255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n选择完以后的样式如下图:\n![image](http://upload-images.jianshu.io/upload_images/1863813-6d5c0ef5154f99aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们可以从上面看到箭头所指的四个地方，一个是Allocations->这个是关于UI布局方面的检测，第二个是Core Animation 这个是关于动画方面的检测，通过Core Animation可以检测到他的帧数，从而判断是不是卡，是否需要进一步完善动画。第三个Leaks就是我们用的最多的内存泄露检测，通过这个，我们可以大致锁定哪些地方可能有内存泄露，然后直接找到有内存泄露的地方，这样可以非常方便我们找到哪里有问题。第四个Time Profiler 这个是检测事件的工具，比如按钮的触发事件等等这些。接下来讲解如何使用它们。\n\n\n这里列举如何使用Leaks这个内存检测工具。\n\n1.首先点开Leaks这个工具，然后选中左上角的Leaks检测选项\n\n2.点击开始运行\n\n3.选择Call tress以一个树形结构来展示\n\n4.在右下角Call Tree选项中选择Separate by Thread 和 Hide System Libraries这两个，其他的展示没研究深刻，没用过，这样我们点击页面就可以看到那些地方有问题，然后我们双击有问题的那个类，就可以找到对应的代码，通过进入xcode去检查就行了。\n\n如图:\n![image](http://upload-images.jianshu.io/upload_images/1863813-b1a96a5a6406a6a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n通过上面的过程以后双击6步骤得到结果如下:\n![image](http://upload-images.jianshu.io/upload_images/1863813-b85f9992e813b53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们可以看到在第一步中我们能看到哪里有问题，然后点击步骤二，就可以直接到达XCode中，这句代码对应的地方，这样就可以找到可能有问题的地方，从而检查出我们项目是否有问题了。\n\n检测动画方面，其实方法也差不多，只是选项不太一样而已。最后选项如图：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-a0912cddcf64e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们需要了解两个两个区域：\n\n这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动\n\n这是重中之重，接下来我会带大家逐个理解、体验这些调试选项\n\n有过游戏经验的人也许对fps这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。根据不同选项可以找到问题，这里我们一项一项的来为大家讲解每一项代表的意思.\n\n1.Color Blended Layers 这个是图层颜色混合的意思.\n\n基本概念:\n\n我们要明白 像素 的概念。屏幕上每一个点都是一个像素点，颜色由R、G、B、alpha组成。如果某一块区域上覆盖了多层layer，最后所计算出来的显示的颜色效果，会受到这些layer的共同影响。举个例子：上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blended)需要消耗一定的GPU资源，在实际开发中可能不止只有两层。如果只想显示最上层的颜色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。\n\nCore Animation Instrucment\n\n类似如下图，可以通过Instrucments来选择Core Animation查看FPS：\n![image](http://upload-images.jianshu.io/upload_images/1863813-8d674ad619395bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n注意:如果要看FPS,需要在真机上运行\n\nDemo优化前\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-915c54bd34f15c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在优化之前，我们通过设置如下方式，可以看到有好多混合的地方，红色部分都是影响滚动时流畅性的。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-b43a2d72946904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nDemo优化后\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-aafaecbaa6be149c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n优化后，我们看到没有中文标签变成绿色了，而有中文的标签还是混合后的颜色。关于有中文的标签如何去优化，这个问题现在没有办法，如果大家有什么好的方法，请一定要告诉我。\n\n优化的代码\n\n在优化前，cell的标题的背景颜色并没有手动设置，而是使用了默认的颜色，这时候即使我们的标题是没有中文的，也会出现混合。而笔者只是添加了一行代码：\n\n\t{self.titleLabel.backgroundColor = self.contentView.backgroundColor;}\n \n这么一行代码，使得标签的背景色和父视图的背景颜色一样，就只可以解决混合的问题（中文除外）。 如何我们设置背景色为clear，一样会出现混合，即使父视图也是clear。\n\n同样，我们在配置CollectionViewCell的时候，也是这么处理：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-90fa702d5a85abe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们设置cell的背景色、collectionview的背景色都为白色，然后titleLabel的背景色与父视图的背景色设置成一样，这样就可以解决混合问题，中文文本除外。\n\n我们尝试设置opaque、alpha都会是图层混合，因此最关键的还是backgroundColor这一关键属性。在实际开发中海油很多控件需要我们注意，这里只是简单介绍。\n\n2.Color Hits Green and Misses Red 光栅化\n\n光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：\n\n\t\t{label.layer.shouldRasterize = YES;}\n\n如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。\n\n光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：\n\n上下微小幅度滑动时，一直是绿色\n\n上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色\n\n如果静止一秒钟，刚开始滑动时会变红。\n\n这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。\n\n光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：\n   \n\t{label.layer.shouldRasterize = YES;}  \n光栅化会  导致离屏渲染，这个下面会讲解。\n\n概念理解\n\nOpenGL中，GPU屏幕渲染有以下两种方式：\n\nOn-Screen Rendering\n\n意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。\n\nOff-Screen Rendering\n\n意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n\n离屏渲染的是是非非\n\n相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：\n\n1.创建新缓冲区；要想进行离屏渲染，首先要创建一个新的缓冲区。\n\n2上下文切换；离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。\n\n离屏渲染触发方式\n\n设置了以下属性时，都会触发离屏绘制：\n\nshouldRasterize（光栅化）\n\nmasks（遮罩）\n\nshadows（阴影）\n\nedge antialiasing（抗锯齿）\n\ngroup opacity（不透明）\n\n需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：cpu渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。\n\n3.Color Offscreen Rendered Yellow 开启以后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。如下图:\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-8b3c71cd6b2a151e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-5269d74977a462ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。\n\n设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-69c5f7ffad543d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n4.Color Copied images 这个是用来检测图片的格式转化的，比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。如果调试时发现有图片被标记为蓝色，说明图片格式有问题。\n\n5.Color Misaligned images 意思就是当图片的像素和目标控件的像素不对齐，就会放一个洋红色的图层在图片上，当图片的像素大小与控件的大小不一致而导致需要缩放时，图片会呈现黄色。\n\n6.Color Compositing Fast Path Blue 标记由硬件标记的路径。蓝色越多越好。\n\n7.Flash Updated Regions 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。\n\n                     注:文章灵感来自同事，如有转载，请注明出处；谢谢。","slug":"性能检测要怎么玩才尽兴/性能检测要怎么玩才尽兴","published":1,"updated":"2017-07-06T09:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xx000b9yhoglz4fcx3","content":"<p>前言:   相信大家平时在利用xcode调试bug的时候经常性的遇到一些莫名其妙的问题，其中就包括崩溃了，打全局断点也不崩溃到某一行，而是直接报野指针的问题，像这种不能具体定位到错误在某一行的代码是最难找到问题的。现在我们可以通过打全局断点，然后xcode自带的内存检测工具来找到问题可能出现的地方。</p>\n<p>打开一个XCode项目，最好是连上真机来测试，这里如果你xcode已经升级到了8.0以上，那么你就必须要有证书才能进行真机调试了。如果在XCode7上面，你是可以直接进行真机测试的。连上手机以后，选择produc-&gt;profile进入XCode自带的调试工具选择页面。<br><a id=\"more\"></a></p>\n<p>如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-5af1b48f8e6ac255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>选择完以后的样式如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-6d5c0ef5154f99aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>我们可以从上面看到箭头所指的四个地方，一个是Allocations-&gt;这个是关于UI布局方面的检测，第二个是Core Animation 这个是关于动画方面的检测，通过Core Animation可以检测到他的帧数，从而判断是不是卡，是否需要进一步完善动画。第三个Leaks就是我们用的最多的内存泄露检测，通过这个，我们可以大致锁定哪些地方可能有内存泄露，然后直接找到有内存泄露的地方，这样可以非常方便我们找到哪里有问题。第四个Time Profiler 这个是检测事件的工具，比如按钮的触发事件等等这些。接下来讲解如何使用它们。</p>\n<p>这里列举如何使用Leaks这个内存检测工具。</p>\n<p>1.首先点开Leaks这个工具，然后选中左上角的Leaks检测选项</p>\n<p>2.点击开始运行</p>\n<p>3.选择Call tress以一个树形结构来展示</p>\n<p>4.在右下角Call Tree选项中选择Separate by Thread 和 Hide System Libraries这两个，其他的展示没研究深刻，没用过，这样我们点击页面就可以看到那些地方有问题，然后我们双击有问题的那个类，就可以找到对应的代码，通过进入xcode去检查就行了。</p>\n<p>如图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b1a96a5a6406a6a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>通过上面的过程以后双击6步骤得到结果如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b85f9992e813b53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后我们可以看到在第一步中我们能看到哪里有问题，然后点击步骤二，就可以直接到达XCode中，这句代码对应的地方，这样就可以找到可能有问题的地方，从而检查出我们项目是否有问题了。</p>\n<p>检测动画方面，其实方法也差不多，只是选项不太一样而已。最后选项如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-a0912cddcf64e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>我们需要了解两个两个区域：</p>\n<p>这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动</p>\n<p>这是重中之重，接下来我会带大家逐个理解、体验这些调试选项</p>\n<p>有过游戏经验的人也许对fps这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。根据不同选项可以找到问题，这里我们一项一项的来为大家讲解每一项代表的意思.</p>\n<p>1.Color Blended Layers 这个是图层颜色混合的意思.</p>\n<p>基本概念:</p>\n<p>我们要明白 像素 的概念。屏幕上每一个点都是一个像素点，颜色由R、G、B、alpha组成。如果某一块区域上覆盖了多层layer，最后所计算出来的显示的颜色效果，会受到这些layer的共同影响。举个例子：上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blended)需要消耗一定的GPU资源，在实际开发中可能不止只有两层。如果只想显示最上层的颜色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。</p>\n<p>Core Animation Instrucment</p>\n<p>类似如下图，可以通过Instrucments来选择Core Animation查看FPS：<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8d674ad619395bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>注意:如果要看FPS,需要在真机上运行</p>\n<p>Demo优化前</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-915c54bd34f15c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在优化之前，我们通过设置如下方式，可以看到有好多混合的地方，红色部分都是影响滚动时流畅性的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b43a2d72946904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>Demo优化后</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-aafaecbaa6be149c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>优化后，我们看到没有中文标签变成绿色了，而有中文的标签还是混合后的颜色。关于有中文的标签如何去优化，这个问题现在没有办法，如果大家有什么好的方法，请一定要告诉我。</p>\n<p>优化的代码</p>\n<p>在优化前，cell的标题的背景颜色并没有手动设置，而是使用了默认的颜色，这时候即使我们的标题是没有中文的，也会出现混合。而笔者只是添加了一行代码：</p>\n<pre><code>{self.titleLabel.backgroundColor = self.contentView.backgroundColor;}\n</code></pre><p>这么一行代码，使得标签的背景色和父视图的背景颜色一样，就只可以解决混合的问题（中文除外）。 如何我们设置背景色为clear，一样会出现混合，即使父视图也是clear。</p>\n<p>同样，我们在配置CollectionViewCell的时候，也是这么处理：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-90fa702d5a85abe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>我们设置cell的背景色、collectionview的背景色都为白色，然后titleLabel的背景色与父视图的背景色设置成一样，这样就可以解决混合问题，中文文本除外。</p>\n<p>我们尝试设置opaque、alpha都会是图层混合，因此最关键的还是backgroundColor这一关键属性。在实际开发中海油很多控件需要我们注意，这里只是简单介绍。</p>\n<p>2.Color Hits Green and Misses Red 光栅化</p>\n<p>光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：</p>\n<pre><code>{label.layer.shouldRasterize = YES;}\n</code></pre><p>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>\n<p>光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：</p>\n<p>上下微小幅度滑动时，一直是绿色</p>\n<p>上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色</p>\n<p>如果静止一秒钟，刚开始滑动时会变红。</p>\n<p>这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。</p>\n<p>光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：</p>\n<pre><code>{label.layer.shouldRasterize = YES;}  \n</code></pre><p>光栅化会  导致离屏渲染，这个下面会讲解。</p>\n<p>概念理解</p>\n<p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>\n<p>On-Screen Rendering</p>\n<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>\n<p>Off-Screen Rendering</p>\n<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>\n<p>离屏渲染的是是非非</p>\n<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>\n<p>1.创建新缓冲区；要想进行离屏渲染，首先要创建一个新的缓冲区。</p>\n<p>2上下文切换；离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>\n<p>离屏渲染触发方式</p>\n<p>设置了以下属性时，都会触发离屏绘制：</p>\n<p>shouldRasterize（光栅化）</p>\n<p>masks（遮罩）</p>\n<p>shadows（阴影）</p>\n<p>edge antialiasing（抗锯齿）</p>\n<p>group opacity（不透明）</p>\n<p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：cpu渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>\n<p>3.Color Offscreen Rendered Yellow 开启以后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。如下图:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8b3c71cd6b2a151e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-5269d74977a462ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。</p>\n<p>设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-69c5f7ffad543d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>4.Color Copied images 这个是用来检测图片的格式转化的，比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。如果调试时发现有图片被标记为蓝色，说明图片格式有问题。</p>\n<p>5.Color Misaligned images 意思就是当图片的像素和目标控件的像素不对齐，就会放一个洋红色的图层在图片上，当图片的像素大小与控件的大小不一致而导致需要缩放时，图片会呈现黄色。</p>\n<p>6.Color Compositing Fast Path Blue 标记由硬件标记的路径。蓝色越多越好。</p>\n<p>7.Flash Updated Regions 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。</p>\n<pre><code>注:文章灵感来自同事，如有转载，请注明出处；谢谢。\n</code></pre>","site":{"data":{}},"excerpt":"<p>前言:   相信大家平时在利用xcode调试bug的时候经常性的遇到一些莫名其妙的问题，其中就包括崩溃了，打全局断点也不崩溃到某一行，而是直接报野指针的问题，像这种不能具体定位到错误在某一行的代码是最难找到问题的。现在我们可以通过打全局断点，然后xcode自带的内存检测工具来找到问题可能出现的地方。</p>\n<p>打开一个XCode项目，最好是连上真机来测试，这里如果你xcode已经升级到了8.0以上，那么你就必须要有证书才能进行真机调试了。如果在XCode7上面，你是可以直接进行真机测试的。连上手机以后，选择produc-&gt;profile进入XCode自带的调试工具选择页面。<br>","more":"</p>\n<p>如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-5af1b48f8e6ac255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>选择完以后的样式如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-6d5c0ef5154f99aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>我们可以从上面看到箭头所指的四个地方，一个是Allocations-&gt;这个是关于UI布局方面的检测，第二个是Core Animation 这个是关于动画方面的检测，通过Core Animation可以检测到他的帧数，从而判断是不是卡，是否需要进一步完善动画。第三个Leaks就是我们用的最多的内存泄露检测，通过这个，我们可以大致锁定哪些地方可能有内存泄露，然后直接找到有内存泄露的地方，这样可以非常方便我们找到哪里有问题。第四个Time Profiler 这个是检测事件的工具，比如按钮的触发事件等等这些。接下来讲解如何使用它们。</p>\n<p>这里列举如何使用Leaks这个内存检测工具。</p>\n<p>1.首先点开Leaks这个工具，然后选中左上角的Leaks检测选项</p>\n<p>2.点击开始运行</p>\n<p>3.选择Call tress以一个树形结构来展示</p>\n<p>4.在右下角Call Tree选项中选择Separate by Thread 和 Hide System Libraries这两个，其他的展示没研究深刻，没用过，这样我们点击页面就可以看到那些地方有问题，然后我们双击有问题的那个类，就可以找到对应的代码，通过进入xcode去检查就行了。</p>\n<p>如图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b1a96a5a6406a6a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>通过上面的过程以后双击6步骤得到结果如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b85f9992e813b53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后我们可以看到在第一步中我们能看到哪里有问题，然后点击步骤二，就可以直接到达XCode中，这句代码对应的地方，这样就可以找到可能有问题的地方，从而检查出我们项目是否有问题了。</p>\n<p>检测动画方面，其实方法也差不多，只是选项不太一样而已。最后选项如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-a0912cddcf64e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>我们需要了解两个两个区域：</p>\n<p>这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动</p>\n<p>这是重中之重，接下来我会带大家逐个理解、体验这些调试选项</p>\n<p>有过游戏经验的人也许对fps这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。根据不同选项可以找到问题，这里我们一项一项的来为大家讲解每一项代表的意思.</p>\n<p>1.Color Blended Layers 这个是图层颜色混合的意思.</p>\n<p>基本概念:</p>\n<p>我们要明白 像素 的概念。屏幕上每一个点都是一个像素点，颜色由R、G、B、alpha组成。如果某一块区域上覆盖了多层layer，最后所计算出来的显示的颜色效果，会受到这些layer的共同影响。举个例子：上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blended)需要消耗一定的GPU资源，在实际开发中可能不止只有两层。如果只想显示最上层的颜色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。</p>\n<p>Core Animation Instrucment</p>\n<p>类似如下图，可以通过Instrucments来选择Core Animation查看FPS：<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8d674ad619395bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>注意:如果要看FPS,需要在真机上运行</p>\n<p>Demo优化前</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-915c54bd34f15c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在优化之前，我们通过设置如下方式，可以看到有好多混合的地方，红色部分都是影响滚动时流畅性的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-b43a2d72946904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>Demo优化后</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-aafaecbaa6be149c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>优化后，我们看到没有中文标签变成绿色了，而有中文的标签还是混合后的颜色。关于有中文的标签如何去优化，这个问题现在没有办法，如果大家有什么好的方法，请一定要告诉我。</p>\n<p>优化的代码</p>\n<p>在优化前，cell的标题的背景颜色并没有手动设置，而是使用了默认的颜色，这时候即使我们的标题是没有中文的，也会出现混合。而笔者只是添加了一行代码：</p>\n<pre><code>{self.titleLabel.backgroundColor = self.contentView.backgroundColor;}\n</code></pre><p>这么一行代码，使得标签的背景色和父视图的背景颜色一样，就只可以解决混合的问题（中文除外）。 如何我们设置背景色为clear，一样会出现混合，即使父视图也是clear。</p>\n<p>同样，我们在配置CollectionViewCell的时候，也是这么处理：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-90fa702d5a85abe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>我们设置cell的背景色、collectionview的背景色都为白色，然后titleLabel的背景色与父视图的背景色设置成一样，这样就可以解决混合问题，中文文本除外。</p>\n<p>我们尝试设置opaque、alpha都会是图层混合，因此最关键的还是backgroundColor这一关键属性。在实际开发中海油很多控件需要我们注意，这里只是简单介绍。</p>\n<p>2.Color Hits Green and Misses Red 光栅化</p>\n<p>光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：</p>\n<pre><code>{label.layer.shouldRasterize = YES;}\n</code></pre><p>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>\n<p>光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：</p>\n<p>上下微小幅度滑动时，一直是绿色</p>\n<p>上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色</p>\n<p>如果静止一秒钟，刚开始滑动时会变红。</p>\n<p>这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。</p>\n<p>光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：</p>\n<pre><code>{label.layer.shouldRasterize = YES;}  \n</code></pre><p>光栅化会  导致离屏渲染，这个下面会讲解。</p>\n<p>概念理解</p>\n<p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>\n<p>On-Screen Rendering</p>\n<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>\n<p>Off-Screen Rendering</p>\n<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>\n<p>离屏渲染的是是非非</p>\n<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>\n<p>1.创建新缓冲区；要想进行离屏渲染，首先要创建一个新的缓冲区。</p>\n<p>2上下文切换；离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>\n<p>离屏渲染触发方式</p>\n<p>设置了以下属性时，都会触发离屏绘制：</p>\n<p>shouldRasterize（光栅化）</p>\n<p>masks（遮罩）</p>\n<p>shadows（阴影）</p>\n<p>edge antialiasing（抗锯齿）</p>\n<p>group opacity（不透明）</p>\n<p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：cpu渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>\n<p>3.Color Offscreen Rendered Yellow 开启以后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。如下图:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-8b3c71cd6b2a151e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-5269d74977a462ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。</p>\n<p>设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-69c5f7ffad543d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>4.Color Copied images 这个是用来检测图片的格式转化的，比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。如果调试时发现有图片被标记为蓝色，说明图片格式有问题。</p>\n<p>5.Color Misaligned images 意思就是当图片的像素和目标控件的像素不对齐，就会放一个洋红色的图层在图片上，当图片的像素大小与控件的大小不一致而导致需要缩放时，图片会呈现黄色。</p>\n<p>6.Color Compositing Fast Path Blue 标记由硬件标记的路径。蓝色越多越好。</p>\n<p>7.Flash Updated Regions 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。</p>\n<pre><code>注:文章灵感来自同事，如有转载，请注明出处；谢谢。\n</code></pre>"},{"title":"抓包工具charles","date":"2017-07-06T07:12:03.000Z","_content":"前言:在任何时候，利用好工具总会给我们生活带来意想不到的惊喜，所谓磨刀不误砍柴工就是这个道理，平时开发的过程中，我们很多时候都是通过NSLog打印来获得结果费时又费力，最近刚好发现一款抓包软件还是挺好用的，只需要简单的设置以后就可以抓取所有的网络请求信息了。\n<!-- more -->\n#### 一:抓取电脑上的包\n1.需要设置一下charles\n![image](http://upload-images.jianshu.io/upload_images/1863813-273a0ddb9bee0f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2.进入设置页面勾选相应选项就可以使用了。\n![image](http://upload-images.jianshu.io/upload_images/1863813-4d87faef41c7f2d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 二:抓取手机上的包\n1.首相将charles的设置里面端口号设置为8888\n![image](http://upload-images.jianshu.io/upload_images/1863813-15c79660913eba76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2.在 iPhone 的 “ 设置 ”–>“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888\n![image](http://upload-images.jianshu.io/upload_images/1863813-d67a0891a19a1306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3.设置好以后会弹出一个请求连接的弹出框，选择allow就可以愉快的抓取你想要的数据了。\n","source":"_posts/抓包工具charles/抓包工具charles.md","raw":"---\ntitle: 抓包工具charles\ndate: 2017-07-06 15:12:03\ntags:\n   - 工具\n---\n前言:在任何时候，利用好工具总会给我们生活带来意想不到的惊喜，所谓磨刀不误砍柴工就是这个道理，平时开发的过程中，我们很多时候都是通过NSLog打印来获得结果费时又费力，最近刚好发现一款抓包软件还是挺好用的，只需要简单的设置以后就可以抓取所有的网络请求信息了。\n<!-- more -->\n#### 一:抓取电脑上的包\n1.需要设置一下charles\n![image](http://upload-images.jianshu.io/upload_images/1863813-273a0ddb9bee0f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2.进入设置页面勾选相应选项就可以使用了。\n![image](http://upload-images.jianshu.io/upload_images/1863813-4d87faef41c7f2d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 二:抓取手机上的包\n1.首相将charles的设置里面端口号设置为8888\n![image](http://upload-images.jianshu.io/upload_images/1863813-15c79660913eba76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2.在 iPhone 的 “ 设置 ”–>“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888\n![image](http://upload-images.jianshu.io/upload_images/1863813-d67a0891a19a1306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3.设置好以后会弹出一个请求连接的弹出框，选择allow就可以愉快的抓取你想要的数据了。\n","slug":"抓包工具charles/抓包工具charles","published":1,"updated":"2017-07-06T07:20:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7xz000d9yhofr7x5kxm","content":"<p>前言:在任何时候，利用好工具总会给我们生活带来意想不到的惊喜，所谓磨刀不误砍柴工就是这个道理，平时开发的过程中，我们很多时候都是通过NSLog打印来获得结果费时又费力，最近刚好发现一款抓包软件还是挺好用的，只需要简单的设置以后就可以抓取所有的网络请求信息了。<br><a id=\"more\"></a></p>\n<h4 id=\"一-抓取电脑上的包\"><a href=\"#一-抓取电脑上的包\" class=\"headerlink\" title=\"一:抓取电脑上的包\"></a>一:抓取电脑上的包</h4><p>1.需要设置一下charles<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-273a0ddb9bee0f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>2.进入设置页面勾选相应选项就可以使用了。<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-4d87faef41c7f2d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"二-抓取手机上的包\"><a href=\"#二-抓取手机上的包\" class=\"headerlink\" title=\"二:抓取手机上的包\"></a>二:抓取手机上的包</h4><p>1.首相将charles的设置里面端口号设置为8888<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-15c79660913eba76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>2.在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-d67a0891a19a1306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>3.设置好以后会弹出一个请求连接的弹出框，选择allow就可以愉快的抓取你想要的数据了。</p>\n","site":{"data":{}},"excerpt":"<p>前言:在任何时候，利用好工具总会给我们生活带来意想不到的惊喜，所谓磨刀不误砍柴工就是这个道理，平时开发的过程中，我们很多时候都是通过NSLog打印来获得结果费时又费力，最近刚好发现一款抓包软件还是挺好用的，只需要简单的设置以后就可以抓取所有的网络请求信息了。<br>","more":"</p>\n<h4 id=\"一-抓取电脑上的包\"><a href=\"#一-抓取电脑上的包\" class=\"headerlink\" title=\"一:抓取电脑上的包\"></a>一:抓取电脑上的包</h4><p>1.需要设置一下charles<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-273a0ddb9bee0f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>2.进入设置页面勾选相应选项就可以使用了。<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-4d87faef41c7f2d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"二-抓取手机上的包\"><a href=\"#二-抓取手机上的包\" class=\"headerlink\" title=\"二:抓取手机上的包\"></a>二:抓取手机上的包</h4><p>1.首相将charles的设置里面端口号设置为8888<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-15c79660913eba76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>2.在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-d67a0891a19a1306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>3.设置好以后会弹出一个请求连接的弹出框，选择allow就可以愉快的抓取你想要的数据了。</p>"},{"title":"配置PodSpec.文件容易遇到的问题","data":"2017-07-05T08:11:32.000Z","_content":"<font color = black size = 3> 前言:相信大部分的iOS程序员都想将自己写的工具上传到cocoaPods供大家使用，网上关于这方面的教程已经太多太多了，但是如果你真正亲自去实践一次，你就会发现里面有很多坑等着你，并不像别人说的轻轻松松就把代码托管到了cocoaPods上面，最近闲来无事，我在经过无数次失败以后，终于使自己的PodSpec.文件通过了验证，这里我将自己遇到的坑给大家列出来，希望能够帮到那些有这方面需求的程序猿。</font>\n\n一:第一坑，所有需要验证的PodSpec.文件都必须要打tag值，不然不能通过验证。(注意:每次打的tag值必须比上次打的tag值大，而且你的版本号也不能小于你的tag值，不然也不能验证通过)\n<!-- more -->\n\n二:第二坑,所有的配置文件验证都是跟github上面的代码进行对比的，所以在修改了本地PodSpec.文件以后，请先上传代码到github再进行 pod lib lint 命令验证\n\n\n三:第三坑,公开头文件的目录请用单引号括起来,如下:\n![image](http://upload-images.jianshu.io/upload_images/1863813-aadb22a032833b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n四:如果你在终端中出现了以下显示，证明你的项目已经发布成功了\n![image](http://upload-images.jianshu.io/upload_images/1863813-97c0e3583265057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n五:一般情况下，在你提交成功以后，其实还是不能再终端中通过pod search 命令搜索到你托管的第三方的，你需要到cocoapods去认领你的第三方\n[传送门](https://trunk.cocoapods.org/claims/new)\n\n六:之后就一直等待发布一段时间，然后就能在cocoapods上面搜索到你的第三方了(注：有时候还是搜索不出来你发布第三方，我们这个时候就可以只通过名字来搜索你的第三方 )\n\npod search +三方名  + simple   \n\n(注:一开始我只能通过上面那种+simple的方式搜索出来，我当时是怀疑是自己的图片资源放在项目中，但是并没有在spec文件中设置规则来约束它，因为我的spec文件在进行验证的过程中报警告了，最后操作了一番，不需要加simple也能搜索出来了。)\n\n(1):  如果还是搜索不出来那就执行 pod setup\n\n发现显示的还是 Unable to find a pod with name, author, summary, or descriptionmatching 'LFBPageScrollView'。\n\n(2)：如果搜索不出来那就更新pod  :\n\n命令:  pod repo update   然后就是等待更新结果\n\n(3): 这个时候咱们就将生成的json文件给删除了\n\npod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。\n\n终端输入rm ~/Library/Caches/CocoaPods/search_index.json\n\n删除成功后再执行pod search\n\n(4):执行pod search \n\n终端输入：pod search LFBPageScrollView(不区分大小写)\n\n输出：Creating search index for spec repo 'master'.. Done!，稍等片刻就会出现所有带LFBPageScrollView字段的类库出现；如果在这种情况下还是搜索不到你的第三方，那么你就只有再仔细检查一下，你之前哪里做的不对。\n\n关于如何更新版本的问题:\n\n在很多时候，我们需要更新迭代我们发布的第三方，我们这个时候只需要做以下几件事就可以轻松的更新原来的东西。\n\n1.需要将spec文件拷贝过来\n\n2.将spec的version 和tag 都改一下\n\n3.通过git打一个新的大于以前的tag值\n\n4.通过pod spec lint 来验证spec文件是否有效\n\n5.将新的spec文件推送到cocoapods上面去\n\n6.再次到cocoapods官网去认领自己的第三方(注:朋友说需要再次领取，也有人说不需要再次认领，不需要再次认领的情况我还是没尝试过，等我试过以后再给大家分享。)\n\n                                    注:(转载请注明出处!!!)\n","source":"_posts/配置PodSpec.文件容易遇到的问题/配置PodSpec.文件容易遇到的问题.md","raw":"---\ntitle: 配置PodSpec.文件容易遇到的问题\ndata: 2017-07-05 16:11:32\ncategories:\ntags:\n   - 黑魔法\n---\n<font color = black size = 3> 前言:相信大部分的iOS程序员都想将自己写的工具上传到cocoaPods供大家使用，网上关于这方面的教程已经太多太多了，但是如果你真正亲自去实践一次，你就会发现里面有很多坑等着你，并不像别人说的轻轻松松就把代码托管到了cocoaPods上面，最近闲来无事，我在经过无数次失败以后，终于使自己的PodSpec.文件通过了验证，这里我将自己遇到的坑给大家列出来，希望能够帮到那些有这方面需求的程序猿。</font>\n\n一:第一坑，所有需要验证的PodSpec.文件都必须要打tag值，不然不能通过验证。(注意:每次打的tag值必须比上次打的tag值大，而且你的版本号也不能小于你的tag值，不然也不能验证通过)\n<!-- more -->\n\n二:第二坑,所有的配置文件验证都是跟github上面的代码进行对比的，所以在修改了本地PodSpec.文件以后，请先上传代码到github再进行 pod lib lint 命令验证\n\n\n三:第三坑,公开头文件的目录请用单引号括起来,如下:\n![image](http://upload-images.jianshu.io/upload_images/1863813-aadb22a032833b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n四:如果你在终端中出现了以下显示，证明你的项目已经发布成功了\n![image](http://upload-images.jianshu.io/upload_images/1863813-97c0e3583265057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n五:一般情况下，在你提交成功以后，其实还是不能再终端中通过pod search 命令搜索到你托管的第三方的，你需要到cocoapods去认领你的第三方\n[传送门](https://trunk.cocoapods.org/claims/new)\n\n六:之后就一直等待发布一段时间，然后就能在cocoapods上面搜索到你的第三方了(注：有时候还是搜索不出来你发布第三方，我们这个时候就可以只通过名字来搜索你的第三方 )\n\npod search +三方名  + simple   \n\n(注:一开始我只能通过上面那种+simple的方式搜索出来，我当时是怀疑是自己的图片资源放在项目中，但是并没有在spec文件中设置规则来约束它，因为我的spec文件在进行验证的过程中报警告了，最后操作了一番，不需要加simple也能搜索出来了。)\n\n(1):  如果还是搜索不出来那就执行 pod setup\n\n发现显示的还是 Unable to find a pod with name, author, summary, or descriptionmatching 'LFBPageScrollView'。\n\n(2)：如果搜索不出来那就更新pod  :\n\n命令:  pod repo update   然后就是等待更新结果\n\n(3): 这个时候咱们就将生成的json文件给删除了\n\npod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。\n\n终端输入rm ~/Library/Caches/CocoaPods/search_index.json\n\n删除成功后再执行pod search\n\n(4):执行pod search \n\n终端输入：pod search LFBPageScrollView(不区分大小写)\n\n输出：Creating search index for spec repo 'master'.. Done!，稍等片刻就会出现所有带LFBPageScrollView字段的类库出现；如果在这种情况下还是搜索不到你的第三方，那么你就只有再仔细检查一下，你之前哪里做的不对。\n\n关于如何更新版本的问题:\n\n在很多时候，我们需要更新迭代我们发布的第三方，我们这个时候只需要做以下几件事就可以轻松的更新原来的东西。\n\n1.需要将spec文件拷贝过来\n\n2.将spec的version 和tag 都改一下\n\n3.通过git打一个新的大于以前的tag值\n\n4.通过pod spec lint 来验证spec文件是否有效\n\n5.将新的spec文件推送到cocoapods上面去\n\n6.再次到cocoapods官网去认领自己的第三方(注:朋友说需要再次领取，也有人说不需要再次认领，不需要再次认领的情况我还是没尝试过，等我试过以后再给大家分享。)\n\n                                    注:(转载请注明出处!!!)\n","slug":"配置PodSpec.文件容易遇到的问题/配置PodSpec.文件容易遇到的问题","published":1,"date":"2017-07-04T09:47:09.000Z","updated":"2017-07-07T09:19:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7y0000f9yho15qdkzs2","content":"<font color=\"black\" size=\"3\"> 前言:相信大部分的iOS程序员都想将自己写的工具上传到cocoaPods供大家使用，网上关于这方面的教程已经太多太多了，但是如果你真正亲自去实践一次，你就会发现里面有很多坑等着你，并不像别人说的轻轻松松就把代码托管到了cocoaPods上面，最近闲来无事，我在经过无数次失败以后，终于使自己的PodSpec.文件通过了验证，这里我将自己遇到的坑给大家列出来，希望能够帮到那些有这方面需求的程序猿。</font>\n\n<p>一:第一坑，所有需要验证的PodSpec.文件都必须要打tag值，不然不能通过验证。(注意:每次打的tag值必须比上次打的tag值大，而且你的版本号也不能小于你的tag值，不然也不能验证通过)<br><a id=\"more\"></a></p>\n<p>二:第二坑,所有的配置文件验证都是跟github上面的代码进行对比的，所以在修改了本地PodSpec.文件以后，请先上传代码到github再进行 pod lib lint 命令验证</p>\n<p>三:第三坑,公开头文件的目录请用单引号括起来,如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-aadb22a032833b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>四:如果你在终端中出现了以下显示，证明你的项目已经发布成功了<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-97c0e3583265057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>五:一般情况下，在你提交成功以后，其实还是不能再终端中通过pod search 命令搜索到你托管的第三方的，你需要到cocoapods去认领你的第三方<br><a href=\"https://trunk.cocoapods.org/claims/new\" target=\"_blank\" rel=\"external\">传送门</a></p>\n<p>六:之后就一直等待发布一段时间，然后就能在cocoapods上面搜索到你的第三方了(注：有时候还是搜索不出来你发布第三方，我们这个时候就可以只通过名字来搜索你的第三方 )</p>\n<p>pod search +三方名  + simple   </p>\n<p>(注:一开始我只能通过上面那种+simple的方式搜索出来，我当时是怀疑是自己的图片资源放在项目中，但是并没有在spec文件中设置规则来约束它，因为我的spec文件在进行验证的过程中报警告了，最后操作了一番，不需要加simple也能搜索出来了。)</p>\n<p>(1):  如果还是搜索不出来那就执行 pod setup</p>\n<p>发现显示的还是 Unable to find a pod with name, author, summary, or descriptionmatching ‘LFBPageScrollView’。</p>\n<p>(2)：如果搜索不出来那就更新pod  :</p>\n<p>命令:  pod repo update   然后就是等待更新结果</p>\n<p>(3): 这个时候咱们就将生成的json文件给删除了</p>\n<p>pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。</p>\n<p>终端输入rm ~/Library/Caches/CocoaPods/search_index.json</p>\n<p>删除成功后再执行pod search</p>\n<p>(4):执行pod search </p>\n<p>终端输入：pod search LFBPageScrollView(不区分大小写)</p>\n<p>输出：Creating search index for spec repo ‘master’.. Done!，稍等片刻就会出现所有带LFBPageScrollView字段的类库出现；如果在这种情况下还是搜索不到你的第三方，那么你就只有再仔细检查一下，你之前哪里做的不对。</p>\n<p>关于如何更新版本的问题:</p>\n<p>在很多时候，我们需要更新迭代我们发布的第三方，我们这个时候只需要做以下几件事就可以轻松的更新原来的东西。</p>\n<p>1.需要将spec文件拷贝过来</p>\n<p>2.将spec的version 和tag 都改一下</p>\n<p>3.通过git打一个新的大于以前的tag值</p>\n<p>4.通过pod spec lint 来验证spec文件是否有效</p>\n<p>5.将新的spec文件推送到cocoapods上面去</p>\n<p>6.再次到cocoapods官网去认领自己的第三方(注:朋友说需要再次领取，也有人说不需要再次认领，不需要再次认领的情况我还是没尝试过，等我试过以后再给大家分享。)</p>\n<pre><code>注:(转载请注明出处!!!)\n</code></pre>","site":{"data":{}},"excerpt":"<font color=\"black\" size=\"3\"> 前言:相信大部分的iOS程序员都想将自己写的工具上传到cocoaPods供大家使用，网上关于这方面的教程已经太多太多了，但是如果你真正亲自去实践一次，你就会发现里面有很多坑等着你，并不像别人说的轻轻松松就把代码托管到了cocoaPods上面，最近闲来无事，我在经过无数次失败以后，终于使自己的PodSpec.文件通过了验证，这里我将自己遇到的坑给大家列出来，希望能够帮到那些有这方面需求的程序猿。</font>\n\n<p>一:第一坑，所有需要验证的PodSpec.文件都必须要打tag值，不然不能通过验证。(注意:每次打的tag值必须比上次打的tag值大，而且你的版本号也不能小于你的tag值，不然也不能验证通过)<br>","more":"</p>\n<p>二:第二坑,所有的配置文件验证都是跟github上面的代码进行对比的，所以在修改了本地PodSpec.文件以后，请先上传代码到github再进行 pod lib lint 命令验证</p>\n<p>三:第三坑,公开头文件的目录请用单引号括起来,如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-aadb22a032833b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>四:如果你在终端中出现了以下显示，证明你的项目已经发布成功了<br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-97c0e3583265057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>五:一般情况下，在你提交成功以后，其实还是不能再终端中通过pod search 命令搜索到你托管的第三方的，你需要到cocoapods去认领你的第三方<br><a href=\"https://trunk.cocoapods.org/claims/new\" target=\"_blank\" rel=\"external\">传送门</a></p>\n<p>六:之后就一直等待发布一段时间，然后就能在cocoapods上面搜索到你的第三方了(注：有时候还是搜索不出来你发布第三方，我们这个时候就可以只通过名字来搜索你的第三方 )</p>\n<p>pod search +三方名  + simple   </p>\n<p>(注:一开始我只能通过上面那种+simple的方式搜索出来，我当时是怀疑是自己的图片资源放在项目中，但是并没有在spec文件中设置规则来约束它，因为我的spec文件在进行验证的过程中报警告了，最后操作了一番，不需要加simple也能搜索出来了。)</p>\n<p>(1):  如果还是搜索不出来那就执行 pod setup</p>\n<p>发现显示的还是 Unable to find a pod with name, author, summary, or descriptionmatching ‘LFBPageScrollView’。</p>\n<p>(2)：如果搜索不出来那就更新pod  :</p>\n<p>命令:  pod repo update   然后就是等待更新结果</p>\n<p>(3): 这个时候咱们就将生成的json文件给删除了</p>\n<p>pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。</p>\n<p>终端输入rm ~/Library/Caches/CocoaPods/search_index.json</p>\n<p>删除成功后再执行pod search</p>\n<p>(4):执行pod search </p>\n<p>终端输入：pod search LFBPageScrollView(不区分大小写)</p>\n<p>输出：Creating search index for spec repo ‘master’.. Done!，稍等片刻就会出现所有带LFBPageScrollView字段的类库出现；如果在这种情况下还是搜索不到你的第三方，那么你就只有再仔细检查一下，你之前哪里做的不对。</p>\n<p>关于如何更新版本的问题:</p>\n<p>在很多时候，我们需要更新迭代我们发布的第三方，我们这个时候只需要做以下几件事就可以轻松的更新原来的东西。</p>\n<p>1.需要将spec文件拷贝过来</p>\n<p>2.将spec的version 和tag 都改一下</p>\n<p>3.通过git打一个新的大于以前的tag值</p>\n<p>4.通过pod spec lint 来验证spec文件是否有效</p>\n<p>5.将新的spec文件推送到cocoapods上面去</p>\n<p>6.再次到cocoapods官网去认领自己的第三方(注:朋友说需要再次领取，也有人说不需要再次认领，不需要再次认领的情况我还是没尝试过，等我试过以后再给大家分享。)</p>\n<pre><code>注:(转载请注明出处!!!)\n</code></pre>"},{"title":"高德地图的使用技巧","date":"2017-07-06T09:02:50.000Z","_content":"\n### 第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-07a90f8b44949eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n这两个字段是ios8.0以后缺省的字段，他主要的意思是提示用户授权使用地图定位时候的提示语。\n\n### 第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了\n\n因为XCode本身就已经集成了高德地图进来，所以用户就没有必要自己去集成高德地图的SDK到项目中了，当然，如果你自己手动集成到项目中，也是可以的。首先我们如果只是需要进行定位的话，那就要了解CoreLocation:定位框架，它在没有地图时也可以使用定位.而在CoreLocation中，我们需要运用到CLLocationManager这个类，他是定位必须要用到的一个类。首先我们先初始化一个CLLocationManager类型的对象,并且给他设置代理。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-f9bc9ec8daea146e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image](http://upload-images.jianshu.io/upload_images/1863813-3fc589854653f983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-52113b6c27e32de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-decc33821a62ab1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第五步：当定位发生错误，就会触发该代理方法\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-0ebf364435f4bf2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image](http://upload-images.jianshu.io/upload_images/1863813-9b989f217455888b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.\n\n如果只是为了简单的调用定位接口来获取当前位置信息，那么用以上的方式就已经足够了，如果需要进行地图显示并且进行导航等功能的实现，那就需要去了解一下MapKit这个框架了。          未完待续...","source":"_posts/高德地图的使用技巧/高德地图的使用技巧.md","raw":"---\ntitle: 高德地图的使用技巧\ndate: 2017-07-06 17:02:50\ntags:\n   - 地图\n---\n\n### 第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件\n![image](http://upload-images.jianshu.io/upload_images/1863813-07a90f8b44949eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n这两个字段是ios8.0以后缺省的字段，他主要的意思是提示用户授权使用地图定位时候的提示语。\n\n### 第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了\n\n因为XCode本身就已经集成了高德地图进来，所以用户就没有必要自己去集成高德地图的SDK到项目中了，当然，如果你自己手动集成到项目中，也是可以的。首先我们如果只是需要进行定位的话，那就要了解CoreLocation:定位框架，它在没有地图时也可以使用定位.而在CoreLocation中，我们需要运用到CLLocationManager这个类，他是定位必须要用到的一个类。首先我们先初始化一个CLLocationManager类型的对象,并且给他设置代理。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-f9bc9ec8daea146e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image](http://upload-images.jianshu.io/upload_images/1863813-3fc589854653f983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-52113b6c27e32de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-decc33821a62ab1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第五步：当定位发生错误，就会触发该代理方法\n\n![image](http://upload-images.jianshu.io/upload_images/1863813-0ebf364435f4bf2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image](http://upload-images.jianshu.io/upload_images/1863813-9b989f217455888b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.\n\n如果只是为了简单的调用定位接口来获取当前位置信息，那么用以上的方式就已经足够了，如果需要进行地图显示并且进行导航等功能的实现，那就需要去了解一下MapKit这个框架了。          未完待续...","slug":"高德地图的使用技巧/高德地图的使用技巧","published":1,"updated":"2017-07-06T09:08:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tpk7y2000g9yhowiz8utrn","content":"<h3 id=\"第一步-在iOS8-0以后，使用高德地图的时候首先要进行配置plist文件\"><a href=\"#第一步-在iOS8-0以后，使用高德地图的时候首先要进行配置plist文件\" class=\"headerlink\" title=\"第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件\"></a>第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-07a90f8b44949eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>这两个字段是ios8.0以后缺省的字段，他主要的意思是提示用户授权使用地图定位时候的提示语。</p>\n<h3 id=\"第二步-在配置好plist文件以后就是正式的使用高德地图进行定位了\"><a href=\"#第二步-在配置好plist文件以后就是正式的使用高德地图进行定位了\" class=\"headerlink\" title=\"第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了\"></a>第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了</h3><p>因为XCode本身就已经集成了高德地图进来，所以用户就没有必要自己去集成高德地图的SDK到项目中了，当然，如果你自己手动集成到项目中，也是可以的。首先我们如果只是需要进行定位的话，那就要了解CoreLocation:定位框架，它在没有地图时也可以使用定位.而在CoreLocation中，我们需要运用到CLLocationManager这个类，他是定位必须要用到的一个类。首先我们先初始化一个CLLocationManager类型的对象,并且给他设置代理。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-f9bc9ec8daea146e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3fc589854653f983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第三步-在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\"><a href=\"#第三步-在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\" class=\"headerlink\" title=\"第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\"></a>第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-52113b6c27e32de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第四步-设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\"><a href=\"#第四步-设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\" class=\"headerlink\" title=\"第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\"></a>第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-decc33821a62ab1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第五步：当定位发生错误，就会触发该代理方法\"><a href=\"#第五步：当定位发生错误，就会触发该代理方法\" class=\"headerlink\" title=\"第五步：当定位发生错误，就会触发该代理方法\"></a>第五步：当定位发生错误，就会触发该代理方法</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-0ebf364435f4bf2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9b989f217455888b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位\"><a href=\"#第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位\" class=\"headerlink\" title=\"第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.\"></a>第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.</h3><p>如果只是为了简单的调用定位接口来获取当前位置信息，那么用以上的方式就已经足够了，如果需要进行地图显示并且进行导航等功能的实现，那就需要去了解一下MapKit这个框架了。          未完待续…</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"第一步-在iOS8-0以后，使用高德地图的时候首先要进行配置plist文件\"><a href=\"#第一步-在iOS8-0以后，使用高德地图的时候首先要进行配置plist文件\" class=\"headerlink\" title=\"第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件\"></a>第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-07a90f8b44949eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>","more":"<p>这两个字段是ios8.0以后缺省的字段，他主要的意思是提示用户授权使用地图定位时候的提示语。</p>\n<h3 id=\"第二步-在配置好plist文件以后就是正式的使用高德地图进行定位了\"><a href=\"#第二步-在配置好plist文件以后就是正式的使用高德地图进行定位了\" class=\"headerlink\" title=\"第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了\"></a>第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了</h3><p>因为XCode本身就已经集成了高德地图进来，所以用户就没有必要自己去集成高德地图的SDK到项目中了，当然，如果你自己手动集成到项目中，也是可以的。首先我们如果只是需要进行定位的话，那就要了解CoreLocation:定位框架，它在没有地图时也可以使用定位.而在CoreLocation中，我们需要运用到CLLocationManager这个类，他是定位必须要用到的一个类。首先我们先初始化一个CLLocationManager类型的对象,并且给他设置代理。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-f9bc9ec8daea146e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-3fc589854653f983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第三步-在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\"><a href=\"#第三步-在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\" class=\"headerlink\" title=\"第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。\"></a>第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-52113b6c27e32de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第四步-设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\"><a href=\"#第四步-设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\" class=\"headerlink\" title=\"第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法\"></a>第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-decc33821a62ab1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第五步：当定位发生错误，就会触发该代理方法\"><a href=\"#第五步：当定位发生错误，就会触发该代理方法\" class=\"headerlink\" title=\"第五步：当定位发生错误，就会触发该代理方法\"></a>第五步：当定位发生错误，就会触发该代理方法</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1863813-0ebf364435f4bf2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1863813-9b989f217455888b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h3 id=\"第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位\"><a href=\"#第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位\" class=\"headerlink\" title=\"第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.\"></a>第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.</h3><p>如果只是为了简单的调用定位接口来获取当前位置信息，那么用以上的方式就已经足够了，如果需要进行地图显示并且进行导航等功能的实现，那就需要去了解一下MapKit这个框架了。          未完待续…</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj4tpk7xi00009yho3bbipeq8","tag_id":"cj4tpk7xo00029yhox5xrmp45","_id":"cj4tpk7xt00079yho5uilhxtt"},{"post_id":"cj4tpk7xm00019yho1678lgom","tag_id":"cj4tpk7xt00069yhoqm8tw24u","_id":"cj4tpk7xy000c9yhosfvffeuw"},{"post_id":"cj4tpk7xr00049yhox6xabsto","tag_id":"cj4tpk7xx000a9yhor6s5uy77","_id":"cj4tpk7y3000i9yho55knbw86"},{"post_id":"cj4tpk7xr00049yhox6xabsto","tag_id":"cj4tpk7xz000e9yhoin4req62","_id":"cj4tpk7y3000j9yhorr1ytn5c"},{"post_id":"cj4tpk7xt00059yho1cgmuoyl","tag_id":"cj4tpk7y3000h9yhoohr7yx4q","_id":"cj4tpk7y6000n9yho6r99eg67"},{"post_id":"cj4tpk7xt00059yho1cgmuoyl","tag_id":"cj4tpk7xt00069yhoqm8tw24u","_id":"cj4tpk7y6000o9yhorxx202zn"},{"post_id":"cj4tpk7xt00059yho1cgmuoyl","tag_id":"cj4tpk7y5000l9yhormntp9nc","_id":"cj4tpk7y8000q9yhou5mrn29s"},{"post_id":"cj4tpk7xu00089yhoy7zwxgfe","tag_id":"cj4tpk7y6000m9yholt7ub780","_id":"cj4tpk7y8000r9yhom0iflumt"},{"post_id":"cj4tpk7xu00089yhoy7zwxgfe","tag_id":"cj4tpk7xt00069yhoqm8tw24u","_id":"cj4tpk7y9000t9yhohym656lk"},{"post_id":"cj4tpk7xu00099yho2kqknw1g","tag_id":"cj4tpk7y7000p9yho8v96wgcs","_id":"cj4tpk7y9000u9yho61f26z6z"},{"post_id":"cj4tpk7xx000b9yhoglz4fcx3","tag_id":"cj4tpk7y8000s9yhoy8ja9eep","_id":"cj4tpk7y9000x9yhoqt535ogr"},{"post_id":"cj4tpk7xx000b9yhoglz4fcx3","tag_id":"cj4tpk7y9000v9yho58gp557i","_id":"cj4tpk7y9000y9yhoa0fdih88"},{"post_id":"cj4tpk7xz000d9yhofr7x5kxm","tag_id":"cj4tpk7y9000w9yho54lrsrlz","_id":"cj4tpk7ya00109yholwz7vqwg"},{"post_id":"cj4tpk7y0000f9yho15qdkzs2","tag_id":"cj4tpk7y9000z9yhovyervkw2","_id":"cj4tpk7yb00129yhom6ynr40i"},{"post_id":"cj4tpk7y2000g9yhowiz8utrn","tag_id":"cj4tpk7yb00119yhoxy33od62","_id":"cj4tpk7yb00139yhow70yht25"}],"Tag":[{"name":"javascript","_id":"cj4tpk7xo00029yhox5xrmp45"},{"name":"技术","_id":"cj4tpk7xt00069yhoqm8tw24u"},{"name":"分享","_id":"cj4tpk7xx000a9yhor6s5uy77"},{"name":"第三方","_id":"cj4tpk7xz000e9yhoin4req62"},{"name":"cocoaPods","_id":"cj4tpk7y3000h9yhoohr7yx4q"},{"name":"终端","_id":"cj4tpk7y5000l9yhormntp9nc"},{"name":"私有库","_id":"cj4tpk7y6000m9yholt7ub780"},{"name":"API","_id":"cj4tpk7y7000p9yho8v96wgcs"},{"name":"Instruments","_id":"cj4tpk7y8000s9yhoy8ja9eep"},{"name":"性能检测","_id":"cj4tpk7y9000v9yho58gp557i"},{"name":"工具","_id":"cj4tpk7y9000w9yho54lrsrlz"},{"name":"黑魔法","_id":"cj4tpk7y9000z9yhovyervkw2"},{"name":"地图","_id":"cj4tpk7yb00119yhoxy33od62"}]}}